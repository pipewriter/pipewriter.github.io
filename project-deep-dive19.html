<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Engine From Scratch – Deep Dive</title>

<!-- ----------  COLOR & TYPOGRAPHY  ---------- -->
<style>
:root{
  /* OKLCH: visually uniform, easy contrast control */
  --bg-0: oklch(18% 0.03 260);
  --bg-1: oklch(24% 0.04 260);
  --surface: oklch(32% 0.05 260);
  --primary: oklch(67% 0.23 282);   /* electric violet */
  --secondary: oklch(70% 0.21 170); /* vivid aquamarine */
  --accent: oklch(82% 0.24 28);     /* warm sunrise */
  --text: oklch(96% 0 0);

  /* sRGB fall‑backs for old browsers */
  --fallback-bg-0:#0e1523;--fallback-bg-1:#141c2e;--fallback-surface:#1a2335;
  --fallback-primary:#bb86fc;--fallback-secondary:#03dac6;--fallback-accent:#ffb74d;--fallback-text:#ffffff;

  --easing:cubic-bezier(.24,.46,.28,.99);
}
@supports (color: oklch(50% 0 0)){
  /* nothing: OKLCH already set */
}
@supports not (color: oklch(50% 0 0)){
  :root{
    --bg-0:var(--fallback-bg-0);--bg-1:var(--fallback-bg-1);--surface:var(--fallback-surface);
    --primary:var(--fallback-primary);--secondary:var(--fallback-secondary);
    --accent:var(--fallback-accent);--text:var(--fallback-text);
  }
}
*{box-sizing:border-box;padding:0;margin:0}
html,body{height:100%;scroll-behavior:smooth;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;color:var(--text);}
body{background:linear-gradient(160deg,var(--bg-0),var(--bg-1));overflow-x:hidden;}
h1,h2,h3{font-weight:600;line-height:1.1}
p{max-width:70ch;margin:1em 0;font-size:1.1rem;opacity:.85}
a{color:var(--secondary);text-decoration:none;position:relative}
a::after{content:"";position:absolute;left:0;right:0;bottom:-2px;height:2px;background:var(--secondary);transform:scaleX(0);transition:transform .3s var(--easing);}
a:hover::after{transform:scaleX(1)}
section{padding:6rem 8vw;position:relative}
section:not(.hero){background:var(--surface);clip-path:inset(0 0 0 0 round 1.2rem)}
section .content{opacity:0;transform:translateY(40px);transition:opacity .6s var(--easing),transform .6s var(--easing);}
section.visible .content{opacity:1;transform:none}
.fancy-bar{height:4px;background:linear-gradient(90deg,var(--primary),var(--secondary),var(--accent));background-size:300% 100%;animation:shift 8s linear infinite}
@keyframes shift{to{background-position:300% 0}}
/* Parallax headline */
.hero h1{font-size:clamp(2.5rem,6vw,6rem);position:relative;z-index:2;mix-blend-mode:plus-lighter;text-align:center;text-shadow:0 0 25px var(--primary)}
/* Hover ring around figures */
figcaption{margin-top:.5rem;font-size:.9rem;text-align:center}
figure{position:relative;display:inline-block;margin:1.5rem}
figure::before{content:"";position:absolute;inset:-8px;border-radius:50%;border:2px solid transparent;transition:border-color .4s var(--easing);}
figure:hover::before{border-color:var(--accent)}
.gallery{display:flex;flex-wrap:wrap;justify-content:center}
.gallery img{width:300px;aspect-ratio:1/1;border-radius:.8rem;object-fit:cover;box-shadow:0 4px 30px rgba(0,0,0,.6)}
/* Scrollbar subtle */
::-webkit-scrollbar{width:10px}
::-webkit-scrollbar-track{background:var(--bg-1)}
::-webkit-scrollbar-thumb{background:var(--primary);border-radius:5px}
</style>
</head>

<body>
<!-- ----------  HERO  ---------- -->
<section class="hero" style="height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden">
  <canvas id="glCanvas" style="position:absolute;top:0;left:0;width:100%;height:100%;"></canvas>
  <h1 data-parallax>ENGINE FROM SCRATCH</h1>
  <div class="fancy-bar" style="width:60%;margin-top:2rem"></div>
</section>

<!-- ----------  OVERVIEW  ---------- -->
<section id="overview">
  <div class="content">
    <h2>Why build an engine from nothing?</h2>
    <p>
      There’s no better way to master the graphics pipeline than <em>owning</em> every stage—asset ingestion,
      ECS, shader hot‑reload, task graph, and platform abstraction. This project began as a learning ledger
      and grew into a full deferred‑renderer with bindless descriptors and a fiber scheduler.
    </p>
  </div>
</section>

<!-- ----------  FEATURES  ---------- -->
<section>
  <div class="content">
    <h2>Feature Highlights</h2>
    <ul style="margin:1.2rem 0 0 1.1rem;font-size:1.05rem;line-height:1.6">
      <li>Clustered lighting with compute‑lane culling (GPU‑driven).</li>
      <li>Virtual textures streaming from <code>.basisu</code> container.</li>
      <li>Zero‑copy hot‑reload for SPIR‑V;&nbsp;<abbr title="120 FPS while recompiling shaders">stalls &lt; 1 ms</abbr>.</li>
      <li>SIMD‑friendly, SoA entity layer – 20 M components in 3 GB.</li>
      <li>Chaos‑monkey stress mode: swaps render graphs on the fly.</li>
    </ul>
  </div>
</section>

<!-- ----------  GALLERY  ---------- -->
<section>
  <div class="content">
    <h2>Live Snapshots</h2>
    <p>The first two frames below were captured directly from the hero WebGL canvas at runtime.</p>
    <div class="gallery" id="gallery">
      <!-- JS injects <figure><img></figure> here -->
    </div>
  </div>
</section>

<!-- ----------  RESULTS  ---------- -->
<section>
  <div class="content">
    <h2>Performance Metrics</h2>
    <p>
      On an Apple M3 Pro running macOS 15 beta the engine sustains <strong>481 fps</strong> in Sponza (2.1 M tris)
      and <strong>11.3 ms</strong> CPU frame time in an all‑threads stress trace (8× 2.5 GHz P‑cores).
      Single‑draw‑call world rendering hits the PCIe limit (~13 GB/s) before the GPU flinches.
    </p>
  </div>
</section>

<!-- ----------  CTA  ---------- -->
<section style="text-align:center">
  <div class="content">
    <h2>Under the hood details?</h2>
    <p>
      The complete post‑mortem (and 4K demo binaries) live on the project’s GitHub release page.<br>
      <a href="https://example.com" target="_blank" rel="noopener">Read the full write‑up →</a>
    </p>
  </div>
</section>

<!-- ----------  SCRIPT  ---------- -->
<script>
/* ---------------------- PARALLAX HEADLINE ---------------------- */
const headline = document.querySelector('[data-parallax]');
window.addEventListener('mousemove',e=>{
  const x = (e.clientX / window.innerWidth - .5)*30;
  const y = (e.clientY / window.innerHeight - .5)*30;
  headline.style.transform = `translate3d(\${x}px,\${y}px,0)`;
});

/* ---------------------- SCROLL REVEAL -------------------------- */
const observer = new IntersectionObserver(entries=>{
  entries.forEach(ent=>{ if(ent.isIntersecting) ent.target.classList.add('visible'); });
},{threshold:.2});
document.querySelectorAll('section').forEach(sec=>observer.observe(sec));

/* ---------------------- MINI WEBGL ENGINE ---------------------- */
const canvas=document.getElementById('glCanvas');
const gl=canvas.getContext('webgl',{antialias:true});
function resize(){canvas.width=window.innerWidth;canvas.height=window.innerHeight;gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);}
window.addEventListener('resize',resize);resize();

/* Shader helpers */
const vsSrc=`
attribute vec3 p;attribute vec3 n;
uniform mat4 mvp,mv,nrm;
varying vec3 vN,vV;
void main(){vN=mat3(nrm)*n;vec4 pos=mv*vec4(p,1.0);vV=-pos.xyz;gl_Position=mvp*vec4(p,1.0);}
`;
const fsSrc=`
precision highp float;
varying vec3 vN,vV;
uniform vec3 lightDir,lightColor,baseColor;
void main(){
  vec3 N=normalize(vN);vec3 V=normalize(vV);
  float diff=max(dot(N,lightDir),0.0);
  vec3 H=normalize(lightDir+V);
  float spec=pow(max(dot(N,H),0.0),64.0);
  vec3 col=baseColor*diff*0.8 + lightColor*spec;
  gl_FragColor=vec4(col,1.0);
}`;
function compile(src,type){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);return s;}
const prog=gl.createProgram();
gl.attachShader(prog,compile(vsSrc,gl.VERTEX_SHADER));
gl.attachShader(prog,compile(fsSrc,gl.FRAGMENT_SHADER));
gl.linkProgram(prog);if(!gl.getProgramParameter(prog,gl.LINK_STATUS))throw gl.getProgramInfoLog(prog);
gl.useProgram(prog);

/* Cube geometry */
const verts=new Float32Array([
  // pos            // normal
  -1,-1,-1, 0,0,-1,  1,-1,-1, 0,0,-1, 1,1,-1, 0,0,-1,  -1,1,-1, 0,0,-1,
  -1,-1, 1, 0,0,1,   1,-1, 1, 0,0,1,  1,1, 1, 0,0,1,   -1,1, 1, 0,0,1,
  -1,-1,-1,-1,0,0,  -1,1,-1,-1,0,0,  -1,1,1,-1,0,0,   -1,-1,1,-1,0,0,
   1,-1,-1,1,0,0,   1,1,-1,1,0,0,    1,1,1,1,0,0,     1,-1,1,1,0,0,
  -1,-1,-1,0,-1,0,  -1,-1,1,0,-1,0,   1,-1,1,0,-1,0,   1,-1,-1,0,-1,0,
  -1,1,-1,0,1,0,   -1,1,1,0,1,0,     1,1,1,0,1,0,     1,1,-1,0,1,0]);
const idxs=new Uint16Array([
  0,1,2, 2,3,0,   4,5,6, 6,7,4,   8,9,10,10,11,8,
  12,13,14,14,15,12, 16,17,18,18,19,16, 20,21,22,22,23,20]);
const vbo=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vbo);gl.bufferData(gl.ARRAY_BUFFER,verts,gl.STATIC_DRAW);
const ibo=gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ibo);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,idxs,gl.STATIC_DRAW);
const stride=6*4;
const locP=gl.getAttribLocation(prog,'p');gl.enableVertexAttribArray(locP);gl.vertexAttribPointer(locP,3,gl.FLOAT,false,stride,0);
const locN=gl.getAttribLocation(prog,'n');gl.enableVertexAttribArray(locN);gl.vertexAttribPointer(locN,3,gl.FLOAT,false,stride,12);

const uniMVP=gl.getUniformLocation(prog,'mvp');
const uniMV =gl.getUniformLocation(prog,'mv');
const uniNRM=gl.getUniformLocation(prog,'nrm');
const uniLD =gl.getUniformLocation(prog,'lightDir');
const uniLC =gl.getUniformLocation(prog,'lightColor');
const uniBC =gl.getUniformLocation(prog,'baseColor');
gl.uniform3f(uniLD, .4,.6,.7);
gl.uniform3f(uniLC,.9,.9,1.0);
gl.uniform3f(uniBC,.55,.4,1.0);
gl.enable(gl.DEPTH_TEST);
gl.clearColor(0,0,0,0);

let then=0,angle=0,framesCaptured=0;
const gallery=document.getElementById('gallery');

function mat4Perspective(out,fovy,aspect,near,far){
  const f=1.0/Math.tan(fovy/2),nf=1/(near-far);
  out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;
  out[4]=0;out[5]=f;out[6]=0;out[7]=0;
  out[8]=0;out[9]=0;out[10]=(far+near)*nf;out[11]=-1;
  out[12]=0;out[13]=0;out[14]=2*far*near*nf;out[15]=0;
}
function mat4Identity(m){m.fill(0);m[0]=m[5]=m[10]=m[15]=1;}
function mat4Translate(m,x,y,z){m[12]+=m[0]*x+m[4]*y+m[8]*z; m[13]+=m[1]*x+m[5]*y+m[9]*z; m[14]+=m[2]*x+m[6]*y+m[10]*z; }
function mat4RotateY(m,rad){
  const c=Math.cos(rad),s=Math.sin(rad);
  const m0=m[0],m4=m[4],m8=m[8];
  m[0]=m0*c+m8*s;
  m[4]=m4*c+m8*s;
  m[8]=m0*-s+m8*c;
}
function mat4Mul(a,b,out){
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      out[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j];
    }
  }
}
const proj=new Float32Array(16),view=new Float32Array(16),model=new Float32Array(16),mv=new Float32Array(16),mvp=new Float32Array(16),normal=new Float32Array(16);
function render(now){
  now*=0.001;const dt=now-then;then=now;angle+=dt*.7;
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  mat4Perspective(proj,Math.PI/3,gl.canvas.width/gl.canvas.height,.1,100);
  mat4Identity(view); mat4Translate(view,0,0,-4);
  mat4Identity(model); mat4RotateY(model,angle);
  mat4Mul(view,model,mv);
  mat4Mul(proj,mv,mvp);
  normal.set(mv);  // for this simple demo we ignore inverse-transpose
  gl.uniformMatrix4fv(uniMV,false,mv);
  gl.uniformMatrix4fv(uniMVP,false,mvp);
  gl.uniformMatrix4fv(uniNRM,false,normal);
  gl.drawElements(gl.TRIANGLES,idxs.length,gl.UNSIGNED_SHORT,0);

  /* capture first two frames to gallery */
  if(framesCaptured<2){
    const img=new Image();
    img.src=canvas.toDataURL('image/png');
    const fig=document.createElement('figure');
    fig.appendChild(img);
    fig.appendChild(Object.assign(document.createElement('figcaption'),{textContent:'Frame '+(framesCaptured+1)}));
    gallery.appendChild(fig);
    framesCaptured++;
  }
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
