
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ENGINE FROM SCRATCH | Graphics Engineer Magnum Opus</title>
<style>
/* ----------  CORE PALETTE (earth-tones, WCAG-checked) ---------- */
:root{
    --earth-1:#2f261f;   /* dark umber */
    --earth-2:#8d6240;   /* roasted pecan */
    --earth-3:#c4b499;   /* sandstone */
    --earth-4:#55624f;   /* moss olive */
    --earth-5:#ede7db;   /* bone */
    --accent :#d08c60;   /* terracotta pop */
}
/* ----------  RESET & BASE ---------- */
*{margin:0;padding:0;box-sizing:border-box;}
html,body{height:100%;scroll-behavior:smooth;font:400 16px/1.6 "Helvetica Neue",Arial,system-ui,sans-serif;color:var(--earth-5);background:var(--earth-1);}
section,header,footer{padding:10vh 8vw;position:relative;overflow:hidden;}
h1,h2{font-weight:700;letter-spacing:.05em;text-transform:uppercase;}
h1{font-size:clamp(2.5rem,6vw,5rem);color:var(--earth-5);}
h2{font-size:clamp(1.8rem,3vw,3rem);color:var(--accent);margin-bottom:1rem;}
p,li{max-width:60ch;}
ul{list-style:none;padding-left:1em;}
ul li::before{content:"▹";color:var(--accent);margin-right:.5em;}
/* ----------  HEADER / HERO ---------- */
header{min-height:100vh;display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;gap:1rem;background:linear-gradient(145deg,var(--earth-2),var(--earth-4));position:relative;}
#heroCanvas{position:absolute;inset:0;z-index:-1;}
/* ----------  NAVBAR ---------- */
#navbar{position:fixed;top:1rem;left:50%;transform:translateX(-50%);background:rgba(47,38,31,.7);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.08);border-radius:50px;padding:.4rem 1.2rem;display:flex;gap:1.2rem;z-index:10;transition:background .3s;}
#navbar a{color:var(--earth-5);text-decoration:none;font-size:.9rem;letter-spacing:.04em;position:relative;}
#navbar a::after{content:"";position:absolute;left:0;bottom:-2px;width:100%;height:2px;background:var(--accent);transform:scaleX(0);transform-origin:left;transition:transform .4s;}
#navbar a:hover::after,#navbar a.active::after{transform:scaleX(1);}
@media(max-width:600px){#navbar{font-size:.8rem;gap:.7rem;padding:.3rem .8rem;}}
/* ----------  SECTIONS ---------- */
.reveal{opacity:0;transform:translateY(60px);transition:opacity .9s cubic-bezier(.33,1,.68,1),transform .9s cubic-bezier(.33,1,.68,1);}
.reveal.in-view{opacity:1;transform:none;}
/* ----------  DEMO CANVAS WRAPPER ---------- */
.demo{display:flex;flex-direction:column;align-items:center;margin:4rem 0;}
.demo canvas{width:100%;max-width:600px;aspect-ratio:16/9;border:2px solid var(--earth-4);border-radius:6px;background:var(--earth-3);}
.demo p{margin-top:.6rem;color:var(--accent);font-weight:600;text-transform:uppercase;letter-spacing:.04em;}
/* ----------  FOOTER ---------- */
footer{background:var(--earth-2);text-align:center;padding:2rem 1rem;font-size:.85rem;letter-spacing:.04em;}
/* ----------  GRAIN OVERLAY ---------- */
#noise{pointer-events:none;position:fixed;inset:0;background:url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNmZmYiLz48L3N2Zz4=');mix-blend-mode:overlay;opacity:.15;background-size:4px;}
/* ----------  SCROLLBAR STYLING ---------- */
::-webkit-scrollbar{width:8px;}
::-webkit-scrollbar-thumb{background:var(--earth-4);border-radius:4px;}
</style>
</head>
<body>

<div id="noise"></div>

<header class="parallax">
    <h1>Engine From Scratch</h1>
    <p>My graphics-engine magnum opus crafted in C++ & Metal</p>
    <canvas id="heroCanvas"></canvas>
</header>

<nav id="navbar">
  <a href="#overview">Overview</a>
  <a href="#tech">Tech</a>
  <a href="#demos">Demos</a>
  <a href="#results">Results</a>
</nav>

<section id="overview" class="reveal">
  <h2>01 – The Why</h2>
  <p>
    I wrote an entire real-time renderer from transistor-level first principles to understand every memory
    fetch between triangle and photon. From bespoke ECS to completely parallel job graph, it is a sandbox where
    modern physically-based shading meets vintage register-level optimisation.
  </p>
</section>

<section id="tech" class="reveal">
  <h2>02 – Tech Stack</h2>
  <ul>
    <li>Hand-rolled C++20 core with metaprogrammed SIMD abstractions</li>
    <li>Custom Vulkan & Metal back-ends targeting desktop and M-series</li>
    <li>Scene graph driven by lock-free entity component system</li>
    <li>GPU ray-traced GI via ReSTIR + SDF cone tracing hybrid</li>
    <li>Asset pipeline authored in Rust for hot-reload builds</li>
  </ul>
</section>

<section id="demos" class="reveal">
  <h2>03 – Interactive Demos</h2>

  <div class="demo">
      <canvas id="cubeCanvas"></canvas>
      <p>Rotating 3D Cube</p>
  </div>

  <div class="demo">
      <canvas id="particlesCanvas"></canvas>
      <p>Particle Swirl</p>
  </div>

  <div class="demo">
      <canvas id="terrainCanvas"></canvas>
      <p>Procedural Terrain</p>
  </div>
</section>

<section id="results" class="reveal">
  <h2>04 – Results</h2>
  <p>
    • Benchmarks show 240 fps @1440p on a single RX 6700XT. <br>
    • Less than 8 ms worst-case frame time spikes thanks to job graph. <br>
    • Achieved sub-3 second full-project hot-reload compile times. <br>
    • Won internal “Most Obsessed With Color Theory” award, obviously.
  </p>
</section>

<footer>
  © 2025 Your Name | Crafted with coffee & earth tones
</footer>

<script>
/* ----------  NAVBAR ACTIVE STATE ---------- */
const navLinks=[...document.querySelectorAll('#navbar a')];
const sections=navLinks.map(a=>document.querySelector(a.getAttribute('href')));
const obsOptions={rootMargin:'-50% 0px -50% 0px',threshold:0};
const navObserver=new IntersectionObserver((entries)=>{
  entries.forEach(entry=>{
    const i=sections.indexOf(entry.target);
    if(entry.isIntersecting){
      navLinks.forEach(l=>l.classList.remove('active'));
      navLinks[i].classList.add('active');
    }
  });
},obsOptions);
sections.forEach(sec=>navObserver.observe(sec));

/* ----------  SCROLL REVEALS ---------- */
const revealObserver=new IntersectionObserver((e)=>{
  e.forEach(x=>x.isIntersecting&&x.target.classList.add('in-view'));
},{threshold:.15});
document.querySelectorAll('.reveal').forEach(el=>revealObserver.observe(el));

/* ----------  PARALLAX HEADER ---------- */
window.addEventListener('scroll',()=>{
  const scrollY=window.scrollY;
  document.querySelector('header').style.transform=`translateY(${scrollY*0.3}px)`;
});

/* ----------  CANVAS UTILS ---------- */
function fitCanvas(c){c.width=c.clientWidth*devicePixelRatio;c.height=c.clientHeight*devicePixelRatio;}
/* ----------  HERO CANVAS: organic gradient swirl ---------- */
(function(){
  const c=document.getElementById('heroCanvas');const ctx=c.getContext('2d');
  fitCanvas(c);
  let t=0;
  function loop(){
    fitCanvas(c);
    const {width:w,height:h}=c;
    const g=ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h)/1.2);
    g.addColorStop(0, 'rgba(208,140,96,0.6)');
    g.addColorStop(.3,'rgba(196,180,153,0.3)');
    g.addColorStop(.6,'rgba(85,98,79,0.25)');
    g.addColorStop(1, 'rgba(47,38,31,0.8)');
    ctx.fillStyle=g;ctx.fillRect(0,0,w,h);
    const waves=7;
    for(let i=0;i<waves;i++){
      ctx.beginPath();
      const amp=20+i*8;
      ctx.moveTo(0, h/2);
      for(let x=0;x<w;x++){
        const y=h/2+Math.sin(x/40+i+t/200)*(amp);
        ctx.lineTo(x,y);
      }
      ctx.lineTo(w,h);ctx.lineTo(0,h);ctx.closePath();
      ctx.fillStyle=`rgba(47,38,31,${0.02+i*0.02})`;
      ctx.fill();
    }
    t++;
    requestAnimationFrame(loop);
  }loop();
})();

/* ----------  CUBE CANVAS ---------- */
(function(){
  const c=document.getElementById('cubeCanvas');const ctx=c.getContext('2d');
  const verts=[[1,1,1],[-1,1,1],[-1,-1,1],[1,-1,1],[1,1,-1],[-1,1,-1],[-1,-1,-1],[1,-1,-1]];
  const faces=[[0,1,2,3],[4,5,6,7],[0,4,5,1],[1,5,6,2],[2,6,7,3],[3,7,4,0]];
  function project([x,y,z],ang){
    const s=Math.sin, c=Math.cos;
    const rx=[x, y*c(ang[0])-z*s(ang[0]), y*s(ang[0])+z*c(ang[0])];
    const ry=[rx[0]*c(ang[1])+rx[2]*s(ang[1]), rx[1], -rx[0]*s(ang[1])+rx[2]*c(ang[1])];
    const rz=[ry[0]*c(ang[2])-ry[1]*s(ang[2]), ry[0]*s(ang[2])+ry[1]*c(ang[2]), ry[2]];
    const d=4, f=200/ (d+rz[2]);
    return [rz[0]*f, rz[1]*f];
  }
  let angle=[0,0,0];
  function loop(){
    fitCanvas(c);const {width:w,height:h}=c;
    ctx.clearRect(0,0,w,h);
    angle=[angle[0]+.01,angle[1]+.013,angle[2]+.02];
    const pts=verts.map(v=>project(v,angle));
    faces.forEach(f=>{
      ctx.beginPath();
      ctx.moveTo(w/2+pts[f[0]][0],h/2+pts[f[0]][1]);
      f.slice(1).forEach(i=>ctx.lineTo(w/2+pts[i][0],h/2+pts[i][1]));
      ctx.closePath();
      ctx.fillStyle='rgba(208,140,96,0.25)';
      ctx.strokeStyle='rgba(197,180,153,0.8)';
      ctx.lineWidth=1.2*devicePixelRatio;
      ctx.fill();ctx.stroke();
    });
    requestAnimationFrame(loop);
  }loop();
})();

/* ----------  PARTICLE SWIRL ---------- */
(function(){
  const c=document.getElementById('particlesCanvas');const ctx=c.getContext('2d');
  const count=500,parts=[];
  function reset(){
    parts.length=0;
    for(let i=0;i<count;i++){
      parts.push({a:Math.random()*Math.PI*2,r:Math.random()*0.4+0.1,spd:Math.random()*0.002+0.001});
    }
  }
  reset();
  function loop(t){
    fitCanvas(c);const {width:w,height:h}=c;
    ctx.fillStyle='rgba(47,38,31,0.1)';ctx.fillRect(0,0,w,h);
    parts.forEach(p=>{
      p.a+=p.spd* (1+p.r);
      const r=p.r* Math.min(w,h)*0.4+40;
      const x=w/2+Math.cos(p.a)*r,y=h/2+Math.sin(p.a)*r;
      ctx.fillStyle='rgba(141,98,64,0.8)';
      ctx.fillRect(x,y,2,2);
    });
    requestAnimationFrame(loop);
  }loop();
})();

/* ----------  PROCEDURAL TERRAIN ---------- */
(function(){
  const c=document.getElementById('terrainCanvas');const ctx=c.getContext('2d');
  function noise(x){return Math.sin(x*12.9898)*43758.5453 %1;}
  function loop(t){
    fitCanvas(c);const {width:w,height:h}=c;
    ctx.fillStyle='rgba(85,98,79,1)';ctx.fillRect(0,0,w,h);
    ctx.strokeStyle='rgba(197,180,153,0.8)';
    ctx.lineWidth=1.2*devicePixelRatio;
    for(let y=0;y<h;y+=8){
      ctx.beginPath();
      for(let x=0;x<w;x++){
        const n=Math.sin((x+t*0.1)*0.01)+Math.cos((y+t*0.1)*0.01);
        const z=(n+2)/4; // 0..1
        ctx.lineTo(x,y-z*20);
      }
      ctx.stroke();
    }
    requestAnimationFrame(loop);
  }loop(0);
})();
</script>
</body>
</html>