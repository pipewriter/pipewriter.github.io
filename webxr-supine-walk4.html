
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Supine Walking Simulator</title><style>body{margin:0;overflow:hidden}</style></head><body><script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script><script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js"></script><script type="module">import{XRControllerModelFactory}from'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/XRControllerModelFactory.js';const scene=new THREE.Scene();scene.background=new THREE.Color(0x88ccee);const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const rig=new THREE.Group();rig.add(camera);scene.add(rig);scene.add(new THREE.Mesh(new THREE.PlaneGeometry(1e3,1e3).rotateX(-Math.PI/2),new THREE.MeshStandardMaterial({color:0x228822})));scene.add(new THREE.HemisphereLight(16777215,4473924,1));const d=new THREE.DirectionalLight(16777215,.8);d.position.set(10,10,10);scene.add(d);for(let i=0;i<200;i++){const m=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({color:Math.random()*16777215}));m.position.set((Math.random()-.5)*100,.5,(Math.random()-.5)*100);scene.add(m);}const cL=renderer.xr.getController(0),cR=renderer.xr.getController(1);rig.add(cL);rig.add(cR);const f=new XRControllerModelFactory(),gL=renderer.xr.getControllerGrip(0);gL.add(f.createControllerModel(gL));scene.add(gL);const gR=renderer.xr.getControllerGrip(1);gR.add(f.createControllerModel(gR));scene.add(gR);let speed=.05,ang=THREE.MathUtils.degToRad(30),prev=0;renderer.setAnimationLoop(()=>{const s=renderer.xr.getSession();if(s){for(const src of s.inputSources){if(!src.gamepad)continue;const gp=src.gamepad,l='left'===src.handedness,r='right'===src.handedness;if(r){const y=-gp.axes[3];if(Math.abs(y)>.1){const dir=new THREE.Vector3(0,1,0).applyQuaternion(camera.quaternion).normalize();rig.position.addScaledVector(dir,speed*y);}}if(l){const x=gp.axes[2];Math.abs(x)>.8&&Math.abs(prev)<=.8&&(rig.rotation.y-=Math.sign(x)*ang);prev=x;}}}renderer.render(scene,camera);});window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)});</script></body></html>
