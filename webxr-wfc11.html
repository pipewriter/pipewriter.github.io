
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from"https://unpkg.com/three@0.157.0/build/three.module.js";import{VRButton}from"https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js";const renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(innerWidth,innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const scene=new THREE.Scene(),camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,.1,1e3),player=new THREE.Group();player.add(camera);scene.add(player);const light=new THREE.DirectionalLight(16777215,1);light.position.set(1,1,1);scene.add(light);const gridSize=40,tileSize=1.5,heightLevels=7,objLevels=5,heightScale=1,eyeHeight=1.6,snapAngle=Math.PI/6;function mk(w,h,f){const a=new Array(h);for(let y=0;y<h;y++){a[y]=new Array(w);for(let x=0;x<w;x++)a[y][x]=f(y,x)}return a}function allowed(t,l){return[t,(t+1)%l,(t+l-1)%l]}function wfc(s,l){const p=mk(s,s,()=>{const a=[];for(let i=0;i<l;i++)a.push(i);return a});let u=!0,g=0;for(;u&&g<s*s*10;){g++;let m=l+1,c=[];for(let y=0;y<s;y++)for(let x=0;x<s;x++){const L=p[y][x].length;L>1&&L<m?(m=L,c=[[x,y]]):L===m&&c.push([x,y])}if(m===l+1){u=!1;break}const[cx,cy]=c[Math.random()*c.length|0],opt=p[cy][cx],pick=opt[Math.random()*opt.length|0];p[cy][cx]=[pick];const q=[[cx,cy]];for(;q.length;){const[qx,qy]=q.shift(),t=p[qy][qx][0];for(const[nx,ny]of[[1,0],[-1,0],[0,1],[0,-1]].map(d=>[qx+d[0],qy+d[1]]).filter(v=>v[0]>=0&&v[0]<s&&v[1]>=0&&v[1]<s)){let poss=p[ny][nx];if(poss.length>1){poss=poss.filter(v=>allowed(t,l).includes(v));poss.length||(poss=[Math.random()*l|0]);poss.length!==p[ny][nx].length&&(p[ny][nx]=poss,q.push([nx,ny]))}}}}return p.map(r=>r.map(v=>v[0]))}const heights=wfc(gridSize+1,heightLevels),objects=wfc(gridSize,objLevels),geom=new THREE.PlaneGeometry(gridSize*tileSize,gridSize*tileSize,gridSize,gridSize).rotateX(-Math.PI/2),pos=geom.attributes.position,cArr=new Float32Array(pos.count*3),col=new THREE.Color;for(let i=0;i<pos.count;i++){const ix=i%(gridSize+1),iz=i/(gridSize+1)|0,h=heights[iz][ix];pos.setY(i,h*heightScale);const t=h/(heightLevels-1);col.setHSL(.3-.3*t,1,.5);cArr[i*3]=col.r;cArr[i*3+1]=col.g;cArr[i*3+2]=col.b}geom.setAttribute("color",new THREE.BufferAttribute(cArr,3));geom.computeVertexNormals();scene.add(new THREE.Mesh(geom,new THREE.MeshStandardMaterial({vertexColors:!0})));const makeShape=[null,()=>new THREE.BoxGeometry(.5*tileSize,.5*tileSize,.5*tileSize),()=>new THREE.SphereGeometry(.25*tileSize,16,16),()=>new THREE.ConeGeometry(.25*tileSize,.5*tileSize,16),()=>new THREE.CylinderGeometry(.25*tileSize,.25*tileSize,.5*tileSize,16)],objCols=[16711680,65280,255,16776960];function getHeight(x,z){const lx=x/tileSize+gridSize/2,lz=z/tileSize+gridSize/2;if(lx<0||lz<0||lx>gridSize||lz>gridSize)return 0;const x0=Math.floor(lx),z0=Math.floor(lz),x1=Math.min(x0+1,gridSize),z1=Math.min(z0+1,gridSize),tx=lx-x0,tz=lz-z0,h00=heights[z0][x0]*heightScale,h10=heights[z0][x1]*heightScale,h01=heights[z1][x0]*heightScale,h11=heights[z1][x1]*heightScale,h0=h00*(1-tx)+h10*tx,h1=h01*(1-tx)+h11*tx;return h0*(1-tz)+h1*tz}for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const id=objects[y][x];if(!id)continue;const geo=makeShape[id](),mat=new THREE.MeshStandardMaterial({color:objCols[(id-1)%objCols.length]}),m=new THREE.Mesh(geo,mat),cx=(x+.5-gridSize/2)*tileSize,cz=(y+.5-gridSize/2)*tileSize; m.position.set(cx,getHeight(cx,cz)+.25*tileSize,cz);scene.add(m)}const clock=new THREE.Clock();let canSnap=!0;renderer.setAnimationLoop(()=>{const dt=clock.getDelta(),ses=renderer.xr.getSession();if(ses)for(const s of ses.inputSources){if(!s.gamepad)continue;const a=s.gamepad.axes,ax=a[2]??a[0],ay=a[3]??a[1];if(s.handedness==="right"){const speed=4*dt,dir=new THREE.Vector3;camera.getWorldDirection(dir);dir.y=0;dir.normalize();const right=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0));player.position.addScaledVector(dir,-ay*speed);player.position.addScaledVector(right,ax*speed)}else{s.handedness==="left"&&(Math.abs(ax)<.3?canSnap=!0:canSnap&&(ax>.8?(player.rotation.y-=snapAngle,canSnap=!1):ax<-.8&&(player.rotation.y+=snapAngle,canSnap=!1)))}}player.position.y=getHeight(player.position.x,player.position.z)+eyeHeight;renderer.render(scene,camera)});addEventListener("resize",()=>{camera.aspect=innerWidth/innerHeight,camera.updateProjectionMatrix(),renderer.setSize(innerWidth,innerHeight)})</script></body></html>
