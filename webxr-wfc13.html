<html><head><meta charset="utf-8"><title>WFC WebXR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import* as THREE from"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";import{VRButton}from"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js";const S=20,H=7,O=5,p=[0xff3e3e,0x3eff3e,0x3e3eff,0xffff3e,0xff3eff,0x3effff,0xffffff];function wfc(s,t){const g=Array.from({length:s},()=>Array.from({length:s},()=>Array.from({length:t},(_,i)=>i))),n=(x,y)=>[[x-1,y],[x+1,y],[x,y-1],[x,y+1]].filter(([a,b])=>a>=0&&a<s&&b>=0&&b<s);for(;;){let m=t+1,e=[];for(let y=0;y<s;y++)for(let x=0;x<s;x++){const c=g[y][x];c.length>1&&(c.length<m?(m=c.length,e=[[x,y]]):c.length===m&&e.push([x,y]))}if(!e.length)break;const[r,u]=e[Math.random()*e.length|0],cell=g[u][r],pick=cell[Math.random()*cell.length|0];g[u][r]=[pick];const st=[[r,u]];for(;st.length;){const[a,b]=st.pop(),v=g[b][a][0];for(const[d,f]of n(a,b)){const nc=g[f][d];if(nc.length>1){const len=nc.length;g[f][d]=nc.filter(z=>z!==v);if(!g[f][d].length)return null;g[f][d].length<len&&st.push([d,f])}}}}return g.map(r=>r.map(c=>c[0]))}let h,o;do{h=wfc(S,H)}while(!h);do{o=wfc(S,O)}while(!o);const scene=new THREE.Scene(),cam=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,.1,1e3),player=new THREE.Group();player.add(cam);scene.add(player);const ren=new THREE.WebGLRenderer({antialias:1});ren.setSize(innerWidth,innerHeight);ren.xr.enabled=1;document.body.appendChild(ren.domElement);document.body.appendChild(VRButton.createButton(ren));const light=new THREE.DirectionalLight(16777215,1);light.position.set(1,2,3);scene.add(light);const gBox=new THREE.BoxGeometry(1,1,1),gSph=new THREE.SphereGeometry(.4,16,16),gCon=new THREE.ConeGeometry(.4,.8,16),gCyl=new THREE.CylinderGeometry(.4,.4,.8,16);for(let z=0;z<S;z++)for(let x=0;x<S;x++){const ht=h[z][x],cube=new THREE.Mesh(gBox,new THREE.MeshLambertMaterial({color:p[ht]}));cube.scale.y=ht+1;cube.position.set(x,(ht+1)/2,z);scene.add(cube);const obj=o[z][x];let shp=null;switch(obj){case 1:shp=new THREE.Mesh(gBox,new THREE.MeshLambertMaterial({color:0xffaaaa}));break;case 2:shp=new THREE.Mesh(gSph,new THREE.MeshLambertMaterial({color:0xaaffaa}));break;case 3:shp=new THREE.Mesh(gCon,new THREE.MeshLambertMaterial({color:0xaaaaff}));break;case 4:shp=new THREE.Mesh(gCyl,new THREE.MeshLambertMaterial({color:0xffffaa}));break;}if(shp){shp.position.set(x,ht+1+.4,z);scene.add(shp)}}addEventListener("resize",()=>{cam.aspect=innerWidth/innerHeight;cam.updateProjectionMatrix();ren.setSize(innerWidth,innerHeight)});const tmpD=new THREE.Vector3(),tmpS=new THREE.Vector3();let prev=0,cd=0;ren.setAnimationLoop(t=>{const d=(t-prev)||0;prev=t;cd=Math.max(0,cd-d/1e3);const ses=ren.xr.getSession();if(ses){for(const src of ses.inputSources){if(!src.gamepad)continue;const a=src.gamepad.axes,l=src.handedness==="left",r=src.handedness==="right";if(r&&a.length>=4){const rx=a[2],ry=a[3],spd=d/1e3*3;cam.getWorldDirection(tmpD);tmpD.y=0;tmpD.normalize();tmpS.copy(tmpD).cross(new THREE.Vector3(0,1,0)).normalize();player.position.add(tmpD.multiplyScalar(-ry*spd));player.position.add(tmpS.multiplyScalar(rx*spd))}if(l&&a.length>=2&&cd===0){const lx=a[0];if(lx>0.8){player.rotation.y-=Math.PI/6;cd=.3}else if(lx<-0.8){player.rotation.y+=Math.PI/6;cd=.3}}}}const gx=Math.round(player.position.x),gz=Math.round(player.position.z);let gr=0;if(gx>=0&&gx<S&&gz>=0&&gz<S)gr=h[gz][gx]+1;player.position.y=gr+1.6;ren.render(scene,cam)});</script></body></html>