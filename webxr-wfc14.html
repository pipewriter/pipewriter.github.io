
<html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import* as THREE from"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";import{VRButton}from"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js";const S=30,H=5,O=[-1,-1,-1,-1,0,1,2,3],C=[0x1b5e20,0x388e3c,0x4caf50,0x8bc34a,0xcddc39],hs=1,eye=1.6,snap=Math.PI/4,speed=3;function wfc(n,v){for(;;){const c=Array.from({length:n},()=>Array.from({length:n},()=>v.slice())),nb=(x,y)=>[[x-1,y],[x+1,y],[x,y-1],[x,y+1]].filter(([a,b])=>a>=0&&a<n&&b>=0&&b<n);let st;while(1){let m=v.length+1,op=[];for(let y=0;y<n;y++)for(let x=0;x<n;x++){const t=c[y][x];if(t.length>1){t.length<m?(m=t.length,op=[[x,y]]):t.length===m&&op.push([x,y])}}if(!op.length)break;const[px,py]=op[Math.random()*op.length|0],val=c[py][px][Math.random()*c[py][px].length|0];c[py][px]=[val];st=[[px,py]];while(st.length){const[sx,sy]=st.pop(),v0=c[sy][sx][0];for(const[nx,ny]of nb(sx,sy)){let l=c[ny][nx];if(l.length>1){const b=l.length;l=l.filter(e=>e!==v0);if(!l.length)break;c[ny][nx]=l,l.length<b&&st.push([nx,ny])}}}}let ok=1;outer:for(let y=0;y<n;y++)for(let x=0;x<n;x++)if(c[y][x].length!==1){ok=0;break outer}if(ok)return c.map(r=>r.map(e=>e[0]))}}const Hm=wfc(S,[...Array(H).keys()]),Om=wfc(S,O),sc=new THREE.Scene();sc.background=new THREE.Color(0x20232a);sc.add(new THREE.HemisphereLight(16777215,0x444444,1));const cam=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,.1,999),rig=new THREE.Group();rig.add(cam);sc.add(rig);const ren=new THREE.WebGLRenderer({antialias:1});ren.setSize(innerWidth,innerHeight);ren.xr.enabled=1;document.body.appendChild(ren.domElement);document.body.appendChild(VRButton.createButton(ren));const boxCache={},box=h=>(boxCache[h]||(boxCache[h]=new THREE.BoxGeometry(1,h*hs,1)));const objs=[new THREE.SphereGeometry(.35,16,16),new THREE.ConeGeometry(.4,.8,16),new THREE.CylinderGeometry(.3,.3,.8,16),new THREE.TorusGeometry(.35,.1,12,24)];for(let z=0;z<S;z++)for(let x=0;x<S;x++){const h=Hm[z][x],b=new THREE.Mesh(box(h+1),new THREE.MeshStandardMaterial({color:C[h]}));b.position.set(x,h*hs/2,z);sc.add(b);const o=Om[z][x];if(o>=0){const m=new THREE.Mesh(objs[o].clone(),new THREE.MeshStandardMaterial({color:Math.random()*16777215}));m.position.set(x,(h+1)*hs,z);sc.add(m)}}addEventListener("resize",()=>{cam.aspect=innerWidth/innerHeight,cam.updateProjectionMatrix(),ren.setSize(innerWidth,innerHeight)});let pv=0,sl=0,sr=0;ren.setAnimationLoop(t=>{const d=(t-pv)/1e3;pv=t;const s=ren.xr.getSession();if(s)for(const i of s.inputSources){if(!i.gamepad)continue;const g=i.gamepad,ax=g.axes[0]||0,ay=g.axes[1]||0;if(i.handedness==="right"){const v=new THREE.Vector3(-ax,0,-ay);v.lengthSq()>.001&&(v.applyAxisAngle(new THREE.Vector3(0,1,0),rig.rotation.y),rig.position.addScaledVector(v,speed*d))}else if(i.handedness==="left"){!sl&&ax<-0.8?(rig.rotation.y+=snap,sl=1):!sr&&ax>0.8&&(rig.rotation.y-=snap,sr=1),Math.abs(ax)<.4&&(sl=sr=0)}}const gx=Math.floor(rig.position.x+.5),gz=Math.floor(rig.position.z+.5);gx>=0&&gz>=0&&gx<S&&gz<S&&(rig.position.y=(Hm[gz][gx]+1)*hs+eye);ren.render(sc,cam)});</script></body></html>
