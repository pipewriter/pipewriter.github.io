
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(innerWidth,innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,.1,1e3),user=new THREE.Group();user.add(camera);scene.add(user);scene.add(new THREE.HemisphereLight(16777215,4473924,1));const G=20,S=1.2,HN=6,ON=6,HS=.5,headH=1.6,snap=Math.PI/6,speed=.05;function wfc(n,g){const p=[],nb=[[1,0],[-1,0],[0,1],[0,-1]],al=t=>[t,(t+1)%n,(t+n-1)%n];for(let y=0;y<g;y++){p[y]=[];for(let x=0;x<g;x++)p[y][x]=[...Array(n).keys()]}let u=!0,c=0;for(;u&&c<g*g*10;){c++;let m=n+1,a=[];for(let y=0;y<g;y++)for(let x=0;x<g;x++){const l=p[y][x].length;l>1&&l<m?(m=l,a=[[x,y]]):l===m&&a.push([x,y])}if(m===n+1){u=!1;break}const[tx,ty]=a[Math.random()*a.length|0],opt=p[ty][tx],pick=opt[Math.random()*opt.length|0];p[ty][tx]=[pick];const q=[[tx,ty]];for(;q.length;){const[qx,qy]=q.shift(),t=p[qy][qx][0];for(const[dX,dY]of nb){const nx=qx+dX,ny=qy+dY;if(nx<0||ny<0||nx>=g||ny>=g)continue;let poss=p[ny][nx];if(poss.length>1){poss=poss.filter(v=>al(t).includes(v));poss.length||(poss=[Math.random()*n|0]);poss.length!==p[ny][nx].length&&(p[ny][nx]=poss,q.push([nx,ny]))}}}}return p.map(r=>r.map(c=>c[0]))}const heights=wfc(HN,G),objs=wfc(ON,G),baseCols=[0x114488,0x228833,0x66aa33,0x887733,0xccbb88,0xffffff];function gH(x,z){const gx=Math.floor(x/S+G/2),gz=Math.floor(z/S+G/2);return gx<0||gz<0||gx>=G||gz>=G?0:heights[gz][gx]*HS}for(let y=0;y<G;y++)for(let x=0;x<G;x++){const h=heights[y][x],sy=h*HS||.1,g=new THREE.BoxGeometry(S,sy,S),col=new THREE.Color(baseCols[h]),cols=[];for(let i=0;i<g.attributes.position.count;i++)cols.push(col.r,col.g,col.b);g.setAttribute('color',new THREE.Float32BufferAttribute(cols,3));const tile=new THREE.Mesh(g,new THREE.MeshStandardMaterial({vertexColors:!0}));tile.position.set((x-G/2)*S,sy/2,(y-G/2)*S);scene.add(tile);const oi=objs[y][x];if(oi){let og;switch(oi){case 1:og=new THREE.BoxGeometry(.4,.4,.4);break;case 2:og=new THREE.SphereGeometry(.25,16,12);break;case 3:og=new THREE.ConeGeometry(.3,.5,8);break;case 4:og=new THREE.CylinderGeometry(.25,.25,.5,8);break;default:og=new THREE.TorusKnotGeometry(.2,.05,64,8)}const om=new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL(Math.random(),.7,.5).getHex()}),o=new THREE.Mesh(og,om);o.position.set((x-G/2)*S,sy+.25,(y-G/2)*S);scene.add(o)}}let ready=!0;renderer.setAnimationLoop(()=>{const ses=renderer.xr.getSession();if(ses)for(const s of ses.inputSources){const g=s.gamepad;if(!g)continue;const a=g.axes;if(s.handedness==='right'){const dx=a[0]||0,dy=a[1]||0,dir=new THREE.Vector3;camera.getWorldDirection(dir);dir.y=0;dir.normalize();const side=new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0),dir).normalize();user.position.addScaledVector(dir,-dy*speed);user.position.addScaledVector(side,dx*speed)}else if(s.handedness==='left'){const rx=a[0]||0;if(Math.abs(rx)>.6&&ready){user.rotation.y+=rx>0?-snap:snap;ready=!1}else Math.abs(rx)<.2&&(ready=!0)}}user.position.y=gH(user.position.x,user.position.z)+headH;renderer.render(scene,camera)});</script></body></html>
