
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(innerWidth,innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const user=new THREE.Group();scene.add(user);const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,.1,1e3);user.add(camera);const light=new THREE.HemisphereLight(16777215,4473924,1);scene.add(light);const gridSize=100,tileSize=1.5,heightColors=[0x228B22,0x32CD32,0xADFF2F,0x8B4513,0xA9A9A9],heightCount=heightColors.length,objectColors=[16711680,255,16776960,16711935],objectCount=objectColors.length+1,terrain=[],downRay=new THREE.Raycaster();downRay.ray.direction.set(0,-1,0);function wfc(s,c){const p=Array.from({length:s},()=>Array.from({length:s},()=>Array.from({length:c},(_,i)=>i))),n=(x,y)=>[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(e=>e[0]>=0&&e[0]<s&&e[1]>=0&&e[1]<s),a=t=>[t,(t+1)%c,(t+c-1)%c];let u=!0,g=0;for(;u&&g<s*s*10;){g++;let m=c+1,ch=[];for(let y=0;y<s;y++)for(let x=0;x<s;x++){const l=p[y][x].length;l>1&&l<m?(m=l,ch=[[x,y]]):l===m&&ch.push([x,y])}if(m===c+1){u=!1;break}const[Cx,Cy]=ch[Math.random()*ch.length|0],opts=p[Cy][Cx],pick=opts[Math.random()*opts.length|0];p[Cy][Cx]=[pick];const q=[[Cx,Cy]];for(;q.length;){const[qx,qy]=q.shift(),t=p[qy][qx][0];for(const[nx,ny]of n(qx,qy)){let poss=p[ny][nx];if(poss.length>1){const as=a(t);if(poss=poss.filter(v=>as.includes(v)),0===poss.length&&(poss=[Math.random()*c|0]),poss.length!==p[ny][nx].length){p[ny][nx]=poss,q.push([nx,ny])}}}}}return p.map(r=>r.map(c=>c[0]))}const heightGrid=wfc(gridSize,heightCount),objectGrid=wfc(gridSize,objectCount);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const hi=heightGrid[y][x],h=.3+.3*hi,geo=new THREE.BoxGeometry(tileSize,h,tileSize);geo.translate(0,h/2,0);const mat=new THREE.MeshStandardMaterial({color:heightColors[hi]}),mesh=new THREE.Mesh(geo,mat);mesh.position.set((x-gridSize/2)*tileSize,0,(y-gridSize/2)*tileSize);scene.add(mesh);terrain.push(mesh);const oi=objectGrid[y][x];if(oi){let og;switch((oi-1)%4){case 0:og=new THREE.BoxGeometry(.5,.5,.5);break;case 1:og=new THREE.SphereGeometry(.25,16,16);break;case 2:og=new THREE.ConeGeometry(.3,.5,16);break;default:og=new THREE.CylinderGeometry(.25,.25,.5,16);}const om=new THREE.MeshStandardMaterial({color:objectColors[(oi-1)%objectColors.length]}),obj=new THREE.Mesh(og,om);obj.position.set((x-gridSize/2)*tileSize,h+.25,(y-gridSize/2)*tileSize);scene.add(obj)}}const cL=renderer.xr.getController(0),cR=renderer.xr.getController(1);scene.add(cL);scene.add(cR);const speed=.05;function loop(){if(renderer.xr.isPresenting){const t=performance.now();[cL,cR].forEach(c=>{if(c.gamepad){const ax=c.gamepad.axes,hand=c.inputSource.handedness;if(hand==='right'){const mx=ax[2]??ax[0],my=ax[3]??ax[1];if(Math.abs(mx)>.2||Math.abs(my)>.2){const dir=new THREE.Vector3;camera.getWorldDirection(dir);dir.y=0;dir.normalize();const right=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();user.position.addScaledVector(dir,-my*speed);user.position.addScaledVector(right,mx*speed)}}else if(hand==='left'){const rx=ax[2]??ax[0];if(Math.abs(rx)>.8&&(t-(c.userData.snap||0)>300)){user.rotation.y-=Math.sign(rx)*Math.PI/4;c.userData.snap=t}}}});downRay.ray.origin.copy(user.position).setY(100);const hit=downRay.intersectObjects(terrain,!1);if(hit.length)user.position.y=hit[0].point.y+1.6}renderer.render(scene,camera)}renderer.setAnimationLoop(loop);addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)});</script></body></html>
