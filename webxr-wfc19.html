<html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import* as THREE from"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";import{VRButton}from"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js";import{XRControllerModelFactory}from"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/XRControllerModelFactory.js";const SIZE=30,HLEV=7,OLEV=7,COL=[0xff3e3e,0x3eff3e,0x3e3eff,0xffff3e,0xff3eff,0x3effff,0xffffff];function wfc(n){const g=Array.from({length:SIZE},_=>Array.from({length:SIZE},_=>Array.from({length:n},(_,i)=>i))),N=(x,y)=>[[x-1,y],[x+1,y],[x,y-1],[x,y+1]].filter(([a,b])=>a>=0&&a<SIZE&&b>=0&&b<SIZE);for(;;){let m=n+1,c=[];for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){let p=g[y][x];p.length>1&&p.length<m?(m=p.length,c=[[x,y]]):p.length===m&&c.push([x,y])}if(!c.length)break;let[r,u]=c[Math.random()*c.length|0],l=g[u][r],e=l[Math.random()*l.length|0];g[u][r]=[e];let q=[[r,u]];for(;q.length;){let[a,b]=q.pop(),v=g[b][a][0];for(let[d,f]of N(a,b)){let w=g[f][d];if(w.length>1){let k=w.length;g[f][d]=w.filter(z=>z!==v);if(!g[f][d].length)return null;g[f][d].length<k&&q.push([d,f])}}}}return g.map(r=>r.map(c=>c[0]))}let hmap,omap;for(;!(hmap=wfc(HLEV)););for(;!(omap=wfc(OLEV)););const scene=new THREE.Scene(),cam=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,.1,1e3),ren=new THREE.WebGLRenderer({antialias:1});ren.setPixelRatio(devicePixelRatio);ren.setSize(innerWidth,innerHeight);ren.xr.enabled=1;document.body.appendChild(ren.domElement);document.body.appendChild(VRButton.createButton(ren));const user=new THREE.Group();user.add(cam);scene.add(user);cam.position.set(0,1.6,0);scene.add(new THREE.HemisphereLight(0xffffff,0x444444,.6));const dl=new THREE.DirectionalLight(0xffffff,.8);dl.position.set(1,2,3);scene.add(dl);const gbox=new THREE.BoxGeometry(1,1,1),gsh=[null,new THREE.SphereGeometry(.4,16,16),new THREE.ConeGeometry(.4,.8,8),new THREE.CylinderGeometry(.3,.3,.8,8),new THREE.BoxGeometry(.8,.8,.8),new THREE.TorusGeometry(.3,.1,8,16),new THREE.DodecahedronGeometry(.5)];for(let z=0;z<SIZE;z++)for(let x=0;x<SIZE;x++){let h=hmap[z][x],mat=new THREE.MeshStandardMaterial({color:COL[h]}),c=new THREE.Mesh(gbox,mat);c.scale.y=h+1;c.position.set(x,(h+1)/2,z);scene.add(c);let o=omap[z][x];if(o){let m=new THREE.Mesh(gsh[o],new THREE.MeshStandardMaterial({color:COL[o]}));m.position.set(x,h+1,z);scene.add(m)}}const fac=new XRControllerModelFactory(),cg1=ren.xr.getControllerGrip(0),cg2=ren.xr.getControllerGrip(1);cg1.add(fac.createControllerModel(cg1));cg2.add(fac.createControllerModel(cg2));user.add(cg1,cg2);const clock=new THREE.Clock();let lastSnap=0;addEventListener("resize",()=>{cam.aspect=innerWidth/innerHeight;cam.updateProjectionMatrix();ren.setSize(innerWidth,innerHeight)});ren.setAnimationLoop(()=>{const t=clock.getElapsedTime(),ses=ren.xr.getSession();if(ses){for(const s of ses.inputSources){const gp=s.gamepad;if(!gp)continue;const ax=gp.axes,hand=s.handedness;if(hand==="right"){let dx=ax[2]||ax[0]||0,dz=ax[3]||ax[1]||0,mv=new THREE.Vector2(dx,-dz);if(mv.length()>.2){mv.multiplyScalar(.05);let a=user.rotation.y;user.position.x+=Math.sin(a)*mv.y+Math.cos(a)*mv.x;user.position.z+=Math.cos(a)*mv.y-Math.sin(a)*mv.x}}else if(hand==="left"){let lx=ax[2]||ax[0]||0;const th=.8;if(lx>th&&t-lastSnap>.3){user.rotation.y-=Math.PI/4;lastSnap=t}else if(lx<-th&&t-lastSnap>.3){user.rotation.y+=Math.PI/4;lastSnap=t}}}let xi=Math.floor(user.position.x+.5),zi=Math.floor(user.position.z+.5);xi>=0&&xi<SIZE&&zi>=0&&zi<SIZE&&(user.position.y=hmap[zi][xi]+1.6)}ren.render(scene,cam)});</script></body></html>