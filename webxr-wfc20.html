
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:1});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=1;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);scene.add(camera);let camTargetY=3;const gridSize=16,tileSize=1.5,baseColors=[0x644100,0x459c3b,0x72cc8b,0xaac67a,0xfbe87e,0x7088c7,0xf3bb7a],objColors=[0x222222,0xff1122,0x22ff99,0x1133ff,0xeb6cff,0xffcd64,0xffffff],heightCount=7,objCount=6,tiles=[];for(let i=0;i<heightCount;i++){const g=new THREE.BoxGeometry(tileSize,.2*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:baseColors[i]});tiles.push(new THREE.Mesh(g,m))}const objPrim=[];for(let i=0;i<objCount;i++){let geo,mat=new THREE.MeshStandardMaterial({color:objColors[i]});if(i===0)geo=null;else if(i===1)geo=new THREE.BoxGeometry(tileSize*0.6,tileSize*0.6,tileSize*0.6);else if(i===2)geo=new THREE.SphereGeometry(tileSize*0.32);else if(i===3)geo=new THREE.CylinderGeometry(tileSize*0.31,tileSize*0.31,tileSize*0.61,16);else if(i===4)geo=new THREE.ConeGeometry(tileSize*0.28,tileSize*0.64,12);else geo=new THREE.TorusGeometry(tileSize*0.22,0.09*tileSize,10,20);if(geo)objPrim.push(new THREE.Mesh(geo,mat));else objPrim.push(null)}const possibilities=[],objPoss=[],heights=[],objs=[];for(let y=0;y<gridSize;y++){possibilities[y]=[];objPoss[y]=[];for(let x=0;x<gridSize;x++)possibilities[y][x]=[0,1,2,3,4,5,6],objPoss[y][x]=[0,1,2,3,4,5]}function allowed(t){return[t,(t+1)%heightCount,(t+heightCount-1)%heightCount]}function objAllowed(o){return o===0?[0,1,2,3,4,5]:[0,o,(o+1)%objCount,(o+objCount-1)%objCount]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapse2d(grid,allowedFn,count){let unresolved=1,guard=0;while(unresolved&&guard<gridSize*gridSize*25){guard++;let min=count+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const l=grid[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min===count+1){unresolved=0;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=grid[cy][cx],pick=options[Math.random()*options.length|0];grid[cy][cx]=[pick];const queue=[[cx,cy]];while(queue.length){const[qx,qy]=queue.shift(),tile=grid[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=grid[ny][nx];if(poss.length>1){const allowedSet=allowedFn(tile);poss=poss.filter(v=>allowedSet.includes(v));if(poss.length===0)poss=[Math.random()*count|0];if(poss.length!==grid[ny][nx].length)grid[ny][nx]=poss,queue.push([nx,ny])}}}}}collapse2d(possibilities,allowed,heightCount);collapse2d(objPoss,objAllowed,objCount);for(let y=0;y<gridSize;y++){heights[y]=[];objs[y]=[];for(let x=0;x<gridSize;x++){const hInd=possibilities[y][x][0],objInd=objPoss[y][x][0];heights[y][x]=hInd;objs[y][x]=objInd}}for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const h=heights[y][x],o=objs[y][x],mesh=tiles[h].clone();mesh.position.set((x-gridSize/2)*tileSize,0.2*tileSize*h,(y-gridSize/2)*tileSize);mesh.userData.h=h;mesh.userData.gridX=x;mesh.userData.gridY=y;scene.add(mesh);if(o&&objPrim[o]){const obj=objPrim[o].clone();obj.position.set(mesh.position.x,(0.2*tileSize*h+.40*tileSize),mesh.position.z);scene.add(obj)}}const ground=new THREE.Mesh(new THREE.PlaneGeometry(gridSize*tileSize,gridSize*tileSize),new THREE.MeshStandardMaterial({color:0x222222,side:2}));ground.rotation.x=-Math.PI/2;ground.position.y=-0.1;scene.add(ground);const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(8,24,4);scene.add(light);let ctrlR,ctrlL;renderer.xr.addEventListener("sessionstart",()=>{const xr=renderer.xr.getSession();function getCtrl(handed){const src=xr.inputSources;for(let s of src)if(s.handedness===handed&&s.gamepad)return s;return null}function updateCtrls(){ctrlR=getCtrl("right"),ctrlL=getCtrl("left")}xr.addEventListener("inputsourceschange",updateCtrls);updateCtrls();});let px=gridSize/2*tileSize,py=3,pz=gridSize/2*tileSize,heading=0;let snapAngle=Math.PI/6,snapWait=0;function tileHeightAt(x,z){let gx=Math.round(x/tileSize+gridSize/2),gz=Math.round(z/tileSize+gridSize/2);if(gx<0||gx>=gridSize||gz<0||gz>=gridSize)return 0;return 0.2*tileSize*heights[gz][gx]+0.8*tileSize;}renderer.setAnimationLoop(()=>{let moved=0,rotated=0;if(renderer.xr.isPresenting){let srcs=renderer.xr.getSession().inputSources;if(ctrlR&&ctrlR.gamepad){let axes=ctrlR.gamepad.axes;let dx=axes[2]||axes[0]||0,dy=axes[3]||axes[1]||0;let moveSpeed=0.09;let localDX=Math.cos(heading)*dx-Math.sin(heading)*dy,localDZ=Math.sin(heading)*dx+Math.cos(heading)*dy;if(Math.abs(dx)>0.17||Math.abs(dy)>0.17){px+=localDX*moveSpeed*tileSize;pz+=localDZ*moveSpeed*tileSize;moved=1;}}if(ctrlL&&ctrlL.gamepad){let axes=ctrlL.gamepad.axes;let a=axes[2]||axes[0]||0;if(Math.abs(a)>0.6&&snapWait<=0){heading+=(a>0?1:-1)*snapAngle;rotated=1;snapWait=12;}if(snapWait>0)snapWait--;if(Math.abs(a)<0.3)snapWait=0;}}}let pyTgt=tileHeightAt(px,pz);camera.position.set(px,pyTgt, pz);camTargetY=pyTgt;camera.rotation.set(0,heading,0,"YXZ");renderer.render(scene,camera)});window.addEventListener("resize",()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();});</script></body></html>
