
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const player={x:0,y:0,z:0,height:1.6,angle:0};let gridSize=16,tileSize=1.5,baseY=0,heightTileCount=5,tileCount=7,objectTileCount=5;const baseColors=[0x4caf50,0x7cb342,0xffeb3b,0xff9800,0x607d8b],objectsColors=[0x000000,0xc62828,0x1976d2,0xfffff0,0x43a047],tiles=[],objectMeshes=[];for(let i=0;i<heightTileCount;i++){let g=new THREE.BoxGeometry(tileSize,.3+tileSize*(i/heightTileCount)*.6,tileSize),m=new THREE.MeshStandardMaterial({color:baseColors[i]});tiles.push({geo:g,mat:m})}for(let i=0;i<objectTileCount;i++){let mesh;switch(i){case 0:mesh=null;break;case 1:mesh=new THREE.Mesh(new THREE.SphereGeometry(.3,24,16),new THREE.MeshStandardMaterial({color:objectsColors[i]}));break;case 2:mesh=new THREE.Mesh(new THREE.ConeGeometry(.3,.7,14),new THREE.MeshStandardMaterial({color:objectsColors[i]}));break;case 3:mesh=new THREE.Mesh(new THREE.TorusKnotGeometry(.22,.1,36,8),new THREE.MeshStandardMaterial({color:objectsColors[i]}));break;case 4:mesh=new THREE.Mesh(new THREE.BoxGeometry(.5,.15,.5),new THREE.MeshStandardMaterial({color:objectsColors[i]}));break;}objectMeshes.push(mesh)}function blank2d(n,m,fn){let arr=[];for(let i=0;i<n;i++){arr[i]=[];for(let j=0;j<m;j++)arr[i][j]=fn?fn(i,j):[];}return arr}function allowed2(h,t){return[h,(h+1)%t,(h+t-1)%t]}function neigh(x,y,size){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(([a,b])=>a>=0&&a<size&&b>=0&&b<size)}function collapseWFC(poss,tileNum){let unresolved=!0,guard=0;for(;unresolved&&guard<poss.length*poss.length*16;){guard++;let min=tileNum+1,choices=[];for(let y=0;y<poss.length;y++)for(let x=0;x<poss.length;x++){let len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(tileNum+1===min){unresolved=!1;break}let[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];let queue=[[cx,cy]];for(;queue.length;){let[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(let[nx,ny]of neigh(qx,qy,poss.length)){let po=poss[ny][nx];if(po.length>1){let allowedSet=allowed2(tile,tileNum);if(po=po.filter(v=>allowedSet.includes(v)),0===po.length&&(po=[Math.random()*tileNum|0]),po.length!==poss[ny][nx].length){poss[ny][nx]=po,queue.push([nx,ny])}}}}}}const heightPoss=blank2d(gridSize,gridSize,()=>{let a=[];for(let i=0;i<heightTileCount;i++)a.push(i);return a});const objPoss=blank2d(gridSize,gridSize,()=>{let a=[];for(let i=0;i<objectTileCount;i++)a.push(i);return a});collapseWFC(heightPoss,heightTileCount);collapseWFC(objPoss,objectTileCount);let mapData=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const h=heightPoss[y][x][0],o=objPoss[y][x][0],base=new THREE.Mesh(tiles[h].geo,tiles[h].mat.clone());base.position.set((x-gridSize/2)*tileSize,baseY, (y-gridSize/2)*tileSize);base.material.color.setHex(baseColors[h]);scene.add(base);if(o>0){const m=objectMeshes[o].clone();m.position.copy(base.position);m.position.y+=.3+.4;scene.add(m)}mapData.push({x,y,h,obj:o,worldX:base.position.x,worldZ:base.position.z,worldY:base.position.y,heightGeom:base})}const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(0,1,0);scene.add(light);let controller,controller2,moveVec=new THREE.Vector2(),snapCooldown=0;function onSessionStart(){let c=renderer.xr.getController(0),c2=renderer.xr.getController(1);controller=c;controller2=c2;controller.addEventListener('connected',e=>{});controller2.addEventListener('connected',e=>{});}renderer.xr.addEventListener('sessionstart',onSessionStart);function getHeightAt(x,z){let gx=Math.round(x/tileSize+gridSize/2),gz=Math.round(z/tileSize+gridSize/2);if(gx>=0&&gx<gridSize&&gz>=0&&gz<gridSize){let idx=gz*gridSize+gx;return mapData[idx]?mapData[idx].heightGeom.position.y+.3+.3*((heightPoss[gz][gx][0])/heightTileCount):0}else return 0}function clamp(val,min,max){return Math.max(min,Math.min(max,val))}function handleControllers(){if(!renderer.xr.isPresenting)return;const gamepads=navigator.getGamepads();let gpL=null,gpR=null;for(let i=0;i<gamepads.length;i++){if(gamepads[i]&&gamepads[i].hand=='left')gpL=gamepads[i];if(gamepads[i]&&gamepads[i].hand=='right')gpR=gamepads[i];}if(!gpL||!gpR)return;let xR=gpR.axes[2]||0,yR=gpR.axes[3]||0,speed=0.07;let forward=new THREE.Vector3(),side=new THREE.Vector3();camera.getWorldDirection(forward);forward.y=0;forward.normalize();side.crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();player.x+=forward.x*yR*speed+side.x*xR*speed;player.z+=forward.z*yR*speed+side.z*xR*speed;let height=getHeightAt(player.x,player.z);player.y=height+player.height;let xL=gpL.axes[2]||0;if(snapCooldown<=0&&Math.abs(xL)>0.7){let rotAmt=(xL>0)?-Math.PI/6:Math.PI/6;player.angle+=rotAmt;snapCooldown=15;}snapCooldown=Math.max(snapCooldown-1,0);}function updateCamera(){camera.position.set(player.x,player.y,player.z);camera.rotation.y=player.angle;}window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)});renderer.setAnimationLoop(()=>{handleControllers();updateCamera();renderer.render(scene,camera)});</script></body></html>
