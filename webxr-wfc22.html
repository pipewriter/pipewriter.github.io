
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let scene=new THREE.Scene,renderer=new THREE.WebGLRenderer({antialias:1});renderer.setSize(window.innerWidth,window.innerHeight),renderer.xr.enabled=!0,document.body.appendChild(renderer.domElement),document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);let playerObj=new THREE.Object3D;scene.add(playerObj),playerObj.add(camera);let light=new THREE.DirectionalLight(16777215,1);light.position.set(0,10,0),scene.add(light);let gridSize=20,tileSize=1.5;let heightCount=7,objCount=5;let heightColors=[16711680,65280,255,16776960,16711935,65535,16777215],heightTiles=[],objTiles=[],objColors=[0x000000,0xcccccc,0xdf5a23,0x3ab167,0x4576e1],nothingIdx=0;for(let i=0;i<heightCount;i++){let g=new THREE.BoxGeometry(tileSize,.25*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:heightColors[i]});heightTiles.push(new THREE.Mesh(g,m))}for(let i=0;i<objCount;i++)if(i!==nothingIdx){let g;switch(i){case 1:g=new THREE.SphereGeometry(.4*tileSize,16,16);break;case 2:g=new THREE.ConeGeometry(.4*tileSize,.9*tileSize,8);break;case 3:g=new THREE.CylinderGeometry(.24*tileSize,.24*tileSize,.8*tileSize,16);break;default:g=new THREE.TorusGeometry(.38*tileSize,.14*tileSize,8,16)}let m=new THREE.MeshStandardMaterial({color:objColors[i]});objTiles[i]=new THREE.Mesh(g,m)}else objTiles[i]=null;let hPoss=[],oPoss=[],heightAllowed=t=>[t,(t+1)%heightCount,(t+heightCount-1)%heightCount],objAllowed=t=>[t,(t+1)%objCount,(t+objCount-1)%objCount];function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(([a,b])=>a>=0&&a<gridSize&&b>=0&&b<gridSize)}function collapseLayer(poss,allowed,maxType){let unresolved=1,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=maxType+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min===maxType+1){unresolved=0;break}let[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];let queue=[[cx,cy]];for(;queue.length;){let[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(let[nx,ny]of neighbors(qx,qy)){let p=poss[ny][nx];if(p.length>1){let allowedSet=allowed(tile);if(p=p.filter(v=>allowedSet.includes(v)),0===p.length&&(p=[Math.random()*maxType|0]),p.length!==poss[ny][nx].length)poss[ny][nx]=p,queue.push([nx,ny])}}}}}for(let y=0;y<gridSize;y++){hPoss[y]=[],oPoss[y]=[];for(let x=0;x<gridSize;x++)hPoss[y][x]=[0,1,2,3,4,5,6],oPoss[y][x]=[0,1,2,3,4]}collapseLayer(hPoss,heightAllowed,heightCount-1),collapseLayer(oPoss,objAllowed,objCount-1);let terrainMeshes=[],objectMeshes=[],heightMap=[];for(let y=0;y<gridSize;y++){heightMap[y]=[];for(let x=0;x<gridSize;x++){let ti=hPoss[y][x][0],mesh=heightTiles[ti].clone(),obji=oPoss[y][x][0],hx=(x-gridSize/2)*tileSize,hy=(y-gridSize/2)*tileSize,vertY=ti*0.7;mesh.position.set(hx,vertY,hy),scene.add(mesh),terrainMeshes.push(mesh),heightMap[y][x]=vertY;if(obji!==nothingIdx&&objTiles[obji]){let o=objTiles[obji].clone();o.position.set(hx,vertY+.45*tileSize,hy),scene.add(o),objectMeshes.push(o)}}}let playerHeight=2,playerX=gridSize/2,playerY=gridSize/2,playerAngle=0,rotSnap=Math.PI/6;function setPlayerPos(x,z){let gridX=Math.round(x),gridY=Math.round(z);gridX<0&&(gridX=0),gridX>=gridSize&&(gridX=gridSize-1),gridY<0&&(gridY=0),gridY>=gridSize&&(gridY=gridSize-1);let vY=heightMap[gridY][gridX];playerObj.position.set((x-gridSize/2)*tileSize,vY+playerHeight,(z-gridSize/2)*tileSize)}setPlayerPos(playerX,playerY);let prevAxes=[0,0,0,0],rotCooldown=0,moveSpeed=0.06,rotThresh=0.4,rotCoolTicks=12;renderer.xr.addEventListener("sessionstart",()=>{let session=renderer.xr.getSession();session.addEventListener("inputsourceschange",()=>{}),renderer.setAnimationLoop(loop)});function loop(){let inputSources=renderer.xr.getSession()?renderer.xr.getSession().inputSources:[];let moved=0;for(const source of inputSources)if(source&&source.gamepad){let axes=source.gamepad.axes;if(axes.length>=4){let[rx,ry,lx,ly]=axes;if(Math.abs(lx)>rotThresh&&rotCooldown<=0){rotCooldown=rotCoolTicks,playerAngle+=lx>0?rotSnap:-rotSnap,playerObj.rotation.y=playerAngle}else rotCooldown>0&&(rotCooldown--,rotCooldown<0&&(rotCooldown=0));let dx=0,dz=0;Math.abs(rx)>.08&&(dx+=rx*moveSpeed),Math.abs(ry)>.08&&(dz+=ry*moveSpeed);let px=playerX+dx*Math.cos(playerAngle)-dz*Math.sin(playerAngle),pz=playerY+dz*Math.cos(playerAngle)+dx*Math.sin(playerAngle);px<0&&(px=0),px>gridSize-1&&(px=gridSize-1),pz<0&&(pz=0),pz>gridSize-1&&(pz=gridSize-1),playerX=px,playerY=pz,setPlayerPos(playerX,playerY),moved=1}}moved||setPlayerPos(playerX,playerY),renderer.render(scene,camera)}renderer.setAnimationLoop(loop);</script></body></html>
