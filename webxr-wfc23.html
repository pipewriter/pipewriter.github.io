
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);camera.position.set(0,8,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);const gridSize=16,tileSize=1.5,heightCount=7,heightColors=[16711680,32639,255,32768,16776960,16711935,65535],objTypes=[null,"cube","sphere","cylinder"],objColors=[0,16711935,65280,65535],groundMeshes=[],heightMap=[],objMap=[],possHeight=[],possObj=[];for(let y=0;y<gridSize;y++){possHeight[y]=[];possObj[y]=[];for(let x=0;x<gridSize;x++)possHeight[y][x]=[0,1,2,3,4,5,6],possObj[y][x]=[0,1,2,3];}function allowedH(t){return[t,(t+1)%heightCount,(t+heightCount-1)%heightCount]}function allowedO(t){return[0,1,2,3]}function nbs(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapse(map,allowed,count){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=99,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=map[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min==99){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=map[cy][cx],pick=options[Math.random()*options.length|0];map[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=map[qy][qx][0];for(const[nx,ny]of nbs(qx,qy)){let poss=map[ny][nx];if(poss.length>1){const allowedSet=allowed(tile);if(poss=poss.filter(v=>allowedSet.includes(v)),poss.length==0&&(poss=[Math.random()*count|0]),poss.length!=map[ny][nx].length){map[ny][nx]=poss,queue.push([nx,ny])}}}}}}collapse(possHeight,allowedH,heightCount);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++)heightMap[y]=heightMap[y]||[],heightMap[y][x]=possHeight[y][x][0];collapse(possObj,allowedO,objTypes.length);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++)objMap[y]=objMap[y]||[],objMap[y][x]=possObj[y][x][0];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const h=heightMap[y][x],geom=new THREE.BoxGeometry(tileSize,.33*tileSize,tileSize),mat=new THREE.MeshStandardMaterial({color:heightColors[h]});const ground=new THREE.Mesh(geom,mat);ground.position.set((x-gridSize/2)*tileSize,h*0.33,(y-gridSize/2)*tileSize);scene.add(ground);groundMeshes.push(ground);let type=objMap[y][x];if(type>0){let m,o;switch(type){case 1:o=new THREE.BoxGeometry(tileSize*.5,tileSize*.5,tileSize*.5);break;case 2:o=new THREE.SphereGeometry(tileSize*.25,16,8);break;case 3:o=new THREE.CylinderGeometry(tileSize*.25,tileSize*.25,tileSize*.6,12);break;}m=new THREE.MeshStandardMaterial({color:objColors[type]});const mesh=new THREE.Mesh(o,m);mesh.position.set((x-gridSize/2)*tileSize,h*0.33+.4,(y-gridSize/2)*tileSize);scene.add(mesh);}}let rig=new THREE.Group;rig.add(camera);scene.add(rig);let snapAngle=Math.PI/6,rotationQueue=0,moving=new THREE.Vector3;function getTileHeight(pos){let gx=Math.round(pos.x/tileSize+gridSize/2),gy=Math.round(pos.z/tileSize+gridSize/2);return(heightMap[gy]&&heightMap[gy][gx]!=null)?heightMap[gy][gx]*0.33:0}function lerp(a,b,t){return a+(b-a)*t}renderer.xr.addEventListener('sessionstart',()=>{let session=renderer.xr.getSession();session.addEventListener("inputsourceschange",()=>{});renderer.setAnimationLoop(renderVR)});function renderVR(){const sess=renderer.xr.getSession();if(sess){for(const src of sess.inputSources){if(!src.gamepad)continue;const{axes,buttons}=src.gamepad;let handedness=src.handedness;if(handedness=="right"){let v=axes[2]??0,h=axes[3]??0;if(Math.abs(v)>.15||Math.abs(h)>.15){let moveSpeed=.08;let dx=h*moveSpeed,dz=v*moveSpeed;const angle=rig.rotation.y;const moveX=Math.sin(angle)*dz+Math.cos(angle)*dx,moveZ=Math.cos(angle)*dz-Math.sin(angle)*dx;moving.set(moveX,0,moveZ)}}if(handedness=="left"){let r=axes[2]??0;if(Math.abs(r)>.7&&rotationQueue==0){rotationQueue=r>0?1:-1}else if(Math.abs(r)<.7){rotationQueue=0}}}}rig.position.x+=moving.x;rig.position.z+=moving.z;let wantY=getTileHeight(rig.position)+1.1;rig.position.y=lerp(rig.position.y,wantY,.3);if(rotationQueue!==0){rig.rotation.y+=snapAngle*rotationQueue;rotationQueue=0}}moving.multiplyScalar(.87);renderer.render(scene,camera);}window.addEventListener("resize",()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)},!1);renderer.setAnimationLoop(()=>{renderer.render(scene,camera)});</script></body></html>
