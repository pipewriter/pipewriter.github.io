
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1000);scene.add(camera);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);const gridSize=20,tileSize=2,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}function randomInt(a){return Math.floor(Math.random()*a)}function allowed(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function wfcInit(vals){for(let y=0;y<gridSize;y++){vals[y]=[];for(let x=0;x<gridSize;x++)vals[y][x]=[...Array(tileCount).keys()];}}function wfcCollapse(poss,adj){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*20;){guard++;let min=tileCount+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min===tileCount+1){unresolved=!1;break}const[cx,cy]=choices[randomInt(choices.length)],options=poss[cy][cx],pick=options[randomInt(options.length)];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss2=poss[ny][nx];if(poss2.length>1){const allowedSet=adj(tile);if(poss2=poss2.filter(v=>allowedSet.includes(v)),0===poss2.length&&(poss2=[randomInt(tileCount)]),poss2.length!==poss[ny][nx].length){poss[ny][nx]=poss2,queue.push([nx,ny])}}}}}}// 1st WFC: Height/colorslet hposs=[],cmpcolor=[0x8DC63F,0x51A6CF,0xD3B889,0x8B5C2A,0xFFFFFF,0xB71C1C,0x212121];wfcInit(hposs);function allowedH(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}wfcCollapse(hposs,allowedH);// 2nd WFC: Primitiveslet oposs=[],objTypeCount=5;// cube, sphere, cone, cylinder, nothinglet primitiveMats=[new THREE.MeshStandardMaterial({color:0xff3131}),new THREE.MeshStandardMaterial({color:0x22eefa}),new THREE.MeshStandardMaterial({color:0xf4df1e}),new THREE.MeshStandardMaterial({color:0x66dd55}),null];wfcInit(oposs);function allowedO(t){return t===0?[0,4]:t===1?[1,4]:t===2?[2,4]:t===3?[3,4]:[0,1,2,3,4]}wfcCollapse(oposs,allowedO);const terrainMeshes=[],objectMeshes=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let tileIndex=hposs[y][x][0],mesh=tiles[tileIndex].clone();let height=tileIndex*0.7;mesh.position.set((x-gridSize/2)*tileSize,height/2,(y-gridSize/2)*tileSize);mesh.scale.y=(0.9+0.7*tileIndex/tileCount);mesh.material=mesh.material.clone();mesh.material.color.setHex(cmpcolor[tileIndex]);scene.add(mesh),terrainMeshes.push(mesh);let ot=oposs[y][x][0];if(ot!==4){let objMesh;switch(ot){case 0:objMesh=new THREE.Mesh(new THREE.BoxGeometry(tileSize*0.35,tileSize*0.35,tileSize*0.35),primitiveMats[0]);break;case 1:objMesh=new THREE.Mesh(new THREE.SphereGeometry(tileSize*0.22,18,18),primitiveMats[1]);break;case 2:objMesh=new THREE.Mesh(new THREE.ConeGeometry(tileSize*0.19,tileSize*0.33,16),primitiveMats[2]);break;case 3:objMesh=new THREE.Mesh(new THREE.CylinderGeometry(tileSize*0.15,tileSize*0.15,tileSize*0.30,16),primitiveMats[3]);break;}objMesh.position.set((x-gridSize/2)*tileSize,height+tileSize*0.23,(y-gridSize/2)*tileSize);scene.add(objMesh);objectMeshes.push(objMesh);}else objectMeshes.push(null);}let player={x:Math.floor(gridSize/2),y:Math.floor(gridSize/2),yaw:0},XRrig=null,XRhead=null,groundOff=2.1,movingF=0,movingS=0,snapTurn=0,snapTick=0;function getGroundHeight(px,py){let x=Math.round(px/(tileSize)),y=Math.round(py/(tileSize));if(x<0||x>=gridSize||y<0||y>=gridSize)return 0;let mesh=terrainMeshes[y*gridSize+x];return mesh?mesh.position.y+tileSize*mesh.scale.y/2:0}function updateRig(rig){let px=player.x,py=player.y;let gx=(px-gridSize/2)*tileSize,gy=(py-gridSize/2)*tileSize,gh=getGroundHeight(px,py);rig.position.set(gx,gh+groundOff,gy);rig.rotation.y=player.yaw;}renderer.xr.addEventListener("sessionstart",()=>{let xrCam=renderer.xr.getCamera(camera);XRrig=new THREE.Group,XRhead=xrCam;XRrig.add(XRhead);scene.add(XRrig)});function movePlayer(forward,strafe){let rad=player.yaw,dx=Math.sin(rad)*forward+Math.cos(rad)*strafe,dz=Math.cos(rad)*forward-Math.sin(rad)*strafe;player.x+=dx*0.15,player.y+=dz*0.15;if(player.x<0)player.x=0;if(player.x>gridSize-1)player.x=gridSize-1;if(player.y<0)player.y=0;if(player.y>gridSize-1)player.y=gridSize-1;}function animate(){// desktop fallbacklet rig=renderer.xr.isPresenting?XRrig:camera;if(rig){if(renderer.xr.isPresenting){updateRig(rig);}else{let gx=(player.x-gridSize/2)*tileSize,gy=(player.y-gridSize/2)*tileSize,gh=getGroundHeight(player.x,player.y);camera.position.set(gx,gh+groundOff,gy);camera.rotation.set(0,player.yaw,0);}}requestAnimationFrame(animate);renderer.render(scene,renderer.xr.isPresenting?XRrig:camera);}animate();// VR Controller movementlet prevAxesL=[0,0],prevAxesR=[0,0];renderer.xr.addEventListener("sessionstart",()=>{let refspace;renderer.xr.getSession().requestReferenceSpace('local').then(rs=>refspace=rs);renderer.setAnimationLoop(()=>{const session=renderer.xr.getSession();const sources=session.inputSources;if(XRrig&&sources.length){for(let input of sources){if(!input.gamepad)continue;let isRight=input.handedness==='right',isLeft=input.handedness==='left';let axes=input.gamepad.axes;let moveSpeed=0.13;let snapAngle=Math.PI/6;let deadz=0.18;if(isRight){let f=-axes[3],s=axes[2];if(Math.abs(f)<deadz)f=0;if(Math.abs(s)<deadz)s=0;movePlayer(f*moveSpeed,s*moveSpeed);}if(isLeft){let x=axes[2],deadZ=0.6;if(Math.abs(x)>deadZ&&snapTick<=0){snapTick=20;player.yaw+=x>0?snapAngle:-snapAngle;}if(Math.abs(x)<=deadZ)snapTick=0;else snapTick--;}}}updateRig(XRrig);renderer.render(scene,XRrig?XRrig:camera);});});window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();});</script></body></html>
