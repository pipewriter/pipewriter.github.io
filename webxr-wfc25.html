
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);let player={height:1.7,position:new THREE.Vector3(0,0,0),yaw:0};camera.position.set(0,player.height,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,10,0);scene.add(light);const ambient=new THREE.AmbientLight(0xffffff,0.3);scene.add(ambient);const gridSize=14,tileSize=2,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,0.18*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}let heightPossibilities=[],objectPossibilities=[];for(let y=0;y<gridSize;y++){heightPossibilities[y]=[];objectPossibilities[y]=[];for(let x=0;x<gridSize;x++)heightPossibilities[y][x]=[0,1,2,3,4,5,6],objectPossibilities[y][x]=[0,1,2,3,4]}function allowed(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function allowedObj(o){return[o,(o+1)%5,0]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapse(poss,allow){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*20;){guard++;let min=9,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min===9){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss2=poss[ny][nx];if(poss2.length>1){const allowedSet=allow(tile);if(poss2=poss2.filter(v=>allowedSet.includes(v)),poss2.length===0&&(poss2=[Math.random()*tileCount|0]),poss2.length!==poss[ny][nx].length){poss[ny][nx]=poss2,queue.push([nx,ny])}}}}}}collapse(heightPossibilities,allowed);collapse(objectPossibilities,allowedObj);function getHeight(x,y){return heightPossibilities[y][x][0]-2}let baseMeshes=[],objectMeshes=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const h=getHeight(x,y),c=colors[heightPossibilities[y][x][0]],geom=new THREE.BoxGeometry(tileSize,0.18*tileSize,tileSize),mat=new THREE.MeshStandardMaterial({color:c,vertexColors:!0}),mesh=new THREE.Mesh(geom,mat);mesh.position.set((x-gridSize/2)*tileSize,h*0.7,(y-gridSize/2)*tileSize);for(let i=0;i<geom.attributes.position.count;i++){let v=geom.attributes.position.getY(i);let cc=new THREE.Color();cc.setHex(c);cc.lerp(new THREE.Color(0x222222),1-v/0.09);geom.attributes.color=new THREE.BufferAttribute(new Float32Array(geom.attributes.position.count*3),3);geom.attributes.color.setXYZ(i,cc.r,cc.g,cc.b);}mesh.geometry=geom;scene.add(mesh);baseMeshes.push(mesh);let obj=objectPossibilities[y][x][0];if(obj>0){let oMesh;switch(obj){case 1:oMesh=new THREE.Mesh(new THREE.SphereGeometry(tileSize*0.25,14,8),new THREE.MeshStandardMaterial({color:0x77eecc}));break;case 2:oMesh=new THREE.Mesh(new THREE.ConeGeometry(tileSize*0.22,tileSize*0.42,7),new THREE.MeshStandardMaterial({color:0xcc7733}));break;case 3:oMesh=new THREE.Mesh(new THREE.CylinderGeometry(tileSize*0.2,tileSize*0.2,tileSize*0.52,10),new THREE.MeshStandardMaterial({color:0x3333cc}));break;case 4:oMesh=new THREE.Mesh(new THREE.TorusGeometry(tileSize*0.18,tileSize*0.07,10,18),new THREE.MeshStandardMaterial({color:0xffff99}));break;}if(oMesh){oMesh.position.set((x-gridSize/2)*tileSize,h*0.7+tileSize*0.20,(y-gridSize/2)*tileSize);scene.add(oMesh);objectMeshes.push(oMesh);}}}function clamp(v,min,max){return Math.max(min,Math.min(v,max))}let prevPadL=0,prevPadR=0,moveVZ=0,moveVX=0,turnTarget=0,turnEase=0,renderYaw=0;renderer.xr.addEventListener("sessionstart",()=>{const session=renderer.xr.getSession();session.addEventListener("inputsourceschange",()=>{}),session.addEventListener("end",()=>{})});function getBaseHeightAt(x,z){let fx=(x/tileSize)+gridSize/2,fz=(z/tileSize)+gridSize/2,ix=Math.floor(fx),iz=Math.floor(fz),ix2=clamp(ix,0,gridSize-1),iz2=clamp(iz,0,gridSize-1);return getHeight(ix2,iz2)*0.7+0.09}let refSpace,ctrls,handlingSnap=0;renderer.xr.addEventListener("sessionstart",()=>{renderer.xr.getSession().requestReferenceSpace("local").then(s=>refSpace=s)});function handleVRInputs(){const ses=renderer.xr.getSession();if(!ses)return;ctrls=ses.inputSources;let dr=0,dx=0,dz=0;for(const c of ctrls){if(c&&c.gamepad){const[ax,ay]=c.handedness==="right"?c.gamepad.axes:[0,0],[lx,ly]=c.handedness==="left"?c.gamepad.axes:[0,0];if(Math.abs(ay)>0.1)dz+=-ay;if(Math.abs(ax)>0.1)dx+=ax;if(Math.abs(lx)>0.3&&!handlingSnap){dr+=-Math.sign(lx)*Math.PI/4;handlingSnap=15}else handlingSnap&&(handlingSnap--)}}
moveVX=dx*0.12,moveVZ=dz*0.12,turnTarget+=dr}renderer.setAnimationLoop((ts,frame)=>{handleVRInputs();let camYaw=player.yaw+turnEase;renderYaw+=(turnTarget-renderYaw)*0.35;turnEase=(turnTarget-renderYaw)*0.8;let sin=Math.sin(renderYaw),cos=Math.cos(renderYaw);player.position.x+=moveVX*cos-moveVZ*sin;player.position.z+=moveVZ*cos+moveVX*sin;let h=getBaseHeightAt(player.position.x,player.position.z)+player.height;camera.position.set(player.position.x,h,player.position.z);camera.rotation.set(0,renderYaw,0);renderer.render(scene,camera)});window.addEventListener("resize",()=>{camera.aspect=window.innerWidth/window.innerHeight,camera.updateProjectionMatrix(),renderer.setSize(window.innerWidth,window.innerHeight)});</script></body></html>
