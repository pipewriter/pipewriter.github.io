
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let gridSize=16,tileSize=1.5,heightTileCount=7,objTileCount=6,heightColors=[16711680,65280,255,16776960,16711935,65535,16777215],heightGeos=[],heightMaterials=[],objColors=[8947848,16747520,4342338,16711935,0,16777215],objTypes=["none","box","sphere","cone","cylinder","tetra"],objGeos=[null,new THREE.BoxGeometry(.7,.7,.7),new THREE.SphereGeometry(.4,16,12),new THREE.ConeGeometry(.5,.8,10),new THREE.CylinderGeometry(.3,.5,.8,10),new THREE.TetrahedronGeometry(.6)],objMaterials=[];for(let i=0;i<heightTileCount;i++)heightMaterials.push(new THREE.MeshStandardMaterial({color:heightColors[i],vertexColors:!0})),heightGeos.push(new THREE.PlaneGeometry(tileSize,tileSize,1,1));for(let i=0;i<objTileCount;i++)objMaterials.push(new THREE.MeshStandardMaterial({color:objColors[i]}));function allowed(h){return[h,(h+1)%heightTileCount,(h+heightTileCount-1)%heightTileCount]}function allowedObj(o){return objTypes[o]=="none"?[0,1,2,3,4,5]:[0,1,2,3,4,5]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}let scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:1});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);camera.position.set(0,5,5);scene.add(camera);let light=new THREE.DirectionalLight(16777215,1);light.position.set(0,10,10);scene.add(light);let hmPoss=[],hmPicked=[],objPoss=[],objPicked=[];for(let y=0;y<gridSize;y++){hmPoss[y]=[];hmPicked[y]=[];objPoss[y]=[];objPicked[y]=[];for(let x=0;x<gridSize;x++)hmPoss[y][x]=[0,1,2,3,4,5,6],objPoss[y][x]=[0,1,2,3,4,5],hmPicked[y][x]=null,objPicked[y][x]=null}function collapseWFC(width,possd,allowedFn){let unresolved=!0,guard=0;for(;unresolved&&guard<width*width*30;){guard++;let min=9,choices=[];for(let y=0;y<width;y++)for(let x=0;x<width;x++){let len=possd[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min>=9){unresolved=!1;break}let[cx,cy]=choices[Math.random()*choices.length|0],options=possd[cy][cx];let pick=options[Math.random()*options.length|0];possd[cy][cx]=[pick];let queue=[[cx,cy]];for(;queue.length;){let[qx,qy]=queue.shift(),tile=possd[qy][qx][0];for(let[nx,ny]of neighbors(qx,qy)){let poss=possd[ny][nx];if(poss.length>1){let allowedSet=allowedFn(tile);poss=poss.filter(v=>allowedSet.includes(v));poss.length||(poss=[Math.random()*options.length|0]);if(poss.length!==possd[ny][nx].length){possd[ny][nx]=poss;queue.push([nx,ny])}}}}}}// Height Map WFCcollapseWFC(gridSize,hmPoss,allowed);// Pick the final height for renderingfor(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++)hmPicked[y][x]=hmPoss[y][x][0];// Object Map WFCbiased to be mostly "none"for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++)objPoss[y][x]=[...(new Array(8)).fill(0),1,2,3,4,5];collapseWFC(gridSize,objPoss,allowedObj);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++)objPicked[y][x]=objPoss[y][x][0];// Generate map let minY=Infinity,maxY=-Infinity,mapMeshes=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let hi=hmPicked[y][x],hval=(hi/heightTileCount-.5)*4,geom=heightGeos[hi].clone(),mat=heightMaterials[hi].clone(),verts=geom.attributes.position;for(let j=0;j<verts.count;j++)geom.attributes.position.setY(j,hval);let colorsArr=new Float32Array(verts.count*3);for(let j=0;j<verts.count;j++){let cc=new THREE.Color(heightColors[hi]);colorsArr[j*3+0]=cc.r;colorsArr[j*3+1]=cc.g;colorsArr[j*3+2]=cc.b}geom.setAttribute('color',new THREE.BufferAttribute(colorsArr,3));let mesh=new THREE.Mesh(geom,mat);mesh.position.set((x-gridSize/2)*tileSize,0,(y-gridSize/2)*tileSize);mesh.rotateX(-Math.PI/2);scene.add(mesh);mapMeshes.push({x,y,h:hval,mesh});minY=Math.min(minY,hval),maxY=Math.max(maxY,hval);// Add object: let oi=objPicked[y][x];if(oi>0&&objGeos[oi]){let obj=new THREE.Mesh(objGeos[oi],objMaterials[oi]);obj.position.set((x-gridSize/2)*tileSize,hval+.7,(y-gridSize/2)*tileSize);scene.add(obj)}}let player=new THREE.Object3D;scene.add(player);let y_offset=1.5;renderer.xr.addEventListener("sessionstart",()=>{player.position.set(0,0,0);});let controllerL=renderer.xr.getController(0),controllerR=renderer.xr.getController(1);scene.add(controllerL,controllerR);let smoothMoveVelocity=new THREE.Vector3,moveSpeed=0.045,rotateSnap=Math.PI/6,snapCooldown=0,prevStickL=0;function findPlayerHeight(px,pz){let tx=Math.round(px/tileSize+gridSize/2),tz=Math.round(pz/tileSize+gridSize/2);if(tx>=0&&tx<gridSize&&tz>=0&&tz<gridSize)return (hmPicked[tz][tx]/heightTileCount-.5)*4;return 0}renderer.setAnimationLoop(()=>{let session=renderer.xr.getSession(),frame=renderer.xr.getFrame();if(session&&frame){let sources=session.inputSources,moveX=0,moveY=0,rotX=0;if(sources)for(let s of sources)if(s.gamepad){let axes=s.gamepad.axes;let handed=s.handedness;if(handed=="right"){moveX+=axes[2]||0;moveY+=axes[3]||0}else{rotX+=axes[2]||0}}if(Math.abs(rotX)>0.8&&snapCooldown<=0){let sign=rotX>0?1:-1;player.rotation.y-=sign*rotateSnap;snapCooldown=.3}else snapCooldown-=.016;let forward=new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0,player.rotation.y,0));let right=new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0,player.rotation.y,0));smoothMoveVelocity.add(forward.multiplyScalar(moveY*moveSpeed));smoothMoveVelocity.add(right.multiplyScalar(moveX*moveSpeed));smoothMoveVelocity.multiplyScalar(.80);player.position.add(smoothMoveVelocity);let py=findPlayerHeight(player.position.x,player.position.z);player.position.y=py+y_offset;let xrCam=renderer.xr.getCamera(camera),base=renderer.xr.getReferenceSpace();xrCam.position.copy(player.position);xrCam.rotation.copy(player.rotation)}renderer.render(scene,renderer.xr.isPresenting?renderer.xr.getCamera(camera):camera)});window.addEventListener("resize",()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});</script></body></html>
