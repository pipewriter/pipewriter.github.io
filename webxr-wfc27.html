
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const PLAYER_HEIGHT=1.7;let playerY=0,playerX=0,playerZ=0,headRot=0;camera.position.set(0,PLAYER_HEIGHT,0);scene.add(camera);const light=new THREE.DirectionalLight(16777215,1);light.position.set(10,50,20);scene.add(light);const gridSize=16,tileSize=1.5,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.18*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}const objectTypes=[null,'box','sphere','cylinder'],objColors=[0,0xffdd44,0x22ff22,0x2288fc],objects={};function makeObject(type){if(!type)return null;if(objects[type])return objects[type].clone();let mesh;if(type==='box'){mesh=new THREE.Mesh(new THREE.BoxGeometry(.45*tileSize,.45*tileSize,.45*tileSize),new THREE.MeshStandardMaterial({color:objColors[1]}));}else if(type==='sphere'){mesh=new THREE.Mesh(new THREE.SphereGeometry(.25*tileSize,12,10),new THREE.MeshStandardMaterial({color:objColors[2]}));}else if(type==='cylinder'){mesh=new THREE.Mesh(new THREE.CylinderGeometry(.2*tileSize,.2*tileSize,.5*tileSize,14),new THREE.MeshStandardMaterial({color:objColors[3]}));}objects[type]=mesh.clone();return mesh}function allowed(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapse(possibilities,allowedFn,count){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*20;){guard++;let min=999,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=possibilities[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(999===min){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=possibilities[cy][cx],pick=options[Math.random()*options.length|0];possibilities[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=possibilities[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=possibilities[ny][nx];if(poss.length>1){const allowedSet=allowedFn(tile);if(poss=poss.filter(v=>allowedSet.includes(v)),0===poss.length&&(poss=[Math.random()*count|0]),poss.length!==possibilities[ny][nx].length){possibilities[ny][nx]=poss,queue.push([nx,ny])}}}}}}// Height/vertex color layer
const heightPoss=[];for(let y=0;y<gridSize;y++){heightPoss[y]=[];for(let x=0;x<gridSize;x++)heightPoss[y][x]=[0,1,2,3,4,5,6]}collapse(heightPoss,allowed,tileCount);// Place tiles according to height & color, build store for next layer
const meshes=[],heightField=[];for(let y=0;y<gridSize;y++){heightField[y]=[];for(let x=0;x<gridSize;x++){const hIdx=heightPoss[y][x][0],mesh=tiles[hIdx].clone(),h=(hIdx-3)*.7;mesh.position.set((x-gridSize/2)*tileSize,h,(y-gridSize/2)*tileSize);mesh.userData={elev:h,color:colors[hIdx]};scene.add(mesh);heightField[y][x]=h;meshes.push(mesh)}}// Second layer: object on top
const objPoss=[];for(let y=0;y<gridSize;y++){objPoss[y]=[];for(let x=0;x<gridSize;x++)objPoss[y][x]=[0,1,2,3]}function allowedObj(a){if(a===0)return[0,1,2,3];return[0,a]}collapse(objPoss,allowedObj,objectTypes.length);// Place objects (mostly empty)
for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const objIdx=objPoss[y][x][0];if(!objIdx)continue;const objType=objectTypes[objIdx],mesh=makeObject(objType);mesh.position.set((x-gridSize/2)*tileSize,heightField[y][x]+tileSize*.375,(y-gridSize/2)*tileSize);scene.add(mesh)}// Player
function getGroundHeight(px,pz){const gx=Math.round(px/tileSize+gridSize/2),gz=Math.round(pz/tileSize+gridSize/2);if(gx<0||gz<0||gx>=gridSize||gz>=gridSize)return 0;return heightField[gz][gx]+PLAYER_HEIGHT}let leftAxisX=0,leftAxisY=0,rightAxisX=0,rightAxisY=0,snapCooldown=0;function handleControllerAxes(){const session=renderer.xr.getSession();if(!session)return;for(const src of session.inputSources){if(!src.gamepad||!src.handedness)continue;const a=src.gamepad.axes;if(src.handedness==='right'){rightAxisX=a[2]??0;rightAxisY=a[3]??0}else if(src.handedness==='left'){leftAxisX=a[2]??0;leftAxisY=a[3]??0}}}function movePlayer(){if(Math.hypot(rightAxisX,rightAxisY)>.08){const moveSpeed=0.04;const ang=headRot+Math.atan2(rightAxisX,rightAxisY);playerX+=Math.sin(ang)*moveSpeed;playerZ+=Math.cos(ang)*moveSpeed;}if(snapCooldown>0)snapCooldown--;if(Math.abs(leftAxisX)>.5&&snapCooldown<=0){headRot+=Math.sign(leftAxisX)*Math.PI/6;snapCooldown=18}}renderer.setAnimationLoop(()=>{handleControllerAxes();movePlayer();const groundY=getGroundHeight(playerX,playerZ);camera.position.set(playerX,groundY,playerZ);camera.rotation.set(0,headRot,0,'YXZ');renderer.render(scene,camera)});window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();});</script></body></html>
