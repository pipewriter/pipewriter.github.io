
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const PLAYER_HEIGHT=1.7;let playerPos=new THREE.Vector3(0,0,0),playerAngle=0;camera.position.set(0,PLAYER_HEIGHT,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);const gridSize=20,tileSize=1.5,heightMin=0,heightMax=5,heightColors=[0x154734,0x36802d,0x84c318,0xffff00,0xd4af37,0xffffff],tileCount=6,tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,0.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:heightColors[i]});tiles.push(new THREE.Mesh(g,m))}const objTypes=[null,'box','sphere','cylinder'],objColors=[0,0xff0033,0x00ffd0,0xffff00];function genWFC(gridSize,count,allowedFn){const poss=[];for(let y=0;y<gridSize;y++){poss[y]=[];for(let x=0;x<gridSize;x++)poss[y][x]=[];for(let t=0;t<count;t++)poss[y][x].push(t)}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}let unresolved=!0,guard=0;while(unresolved&&guard<gridSize*gridSize*20){guard++;let min=100,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const l=poss[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min===100){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];while(queue.length){const[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let p=poss[ny][nx];if(p.length>1){let allowedSet=allowedFn(tile);p=p.filter(v=>allowedSet.includes(v));if(p.length===0)p=[Math.random()*count|0];if(p.length!==poss[ny][nx].length){poss[ny][nx]=p;queue.push([nx,ny])}}}}}return poss.map(row=>row.map(arr=>arr[0]))}function allowedH(t){return[t,Math.max(0,t-1),Math.min(tileCount-1,t+1)]}function allowedO(t){return[t,(t+1)%objTypes.length,(t+objTypes.length-1)%objTypes.length]}const heights=genWFC(gridSize,tileCount,allowedH),objects=genWFC(gridSize,objTypes.length,allowedO);const groundGroup=new THREE.Group();for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const h=heights[y][x],tile=tiles[h].clone();tile.position.set((x-gridSize/2)*tileSize,h*0.61,(y-gridSize/2)*tileSize);tile.material=tile.material.clone();tile.material.vertexColors=false;tile.userData={height:h};groundGroup.add(tile);const o=objects[y][x];if(o&&objTypes[o]){let objMesh;switch(objTypes[o]){case'box':objMesh=new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7),new THREE.MeshStandardMaterial({color:objColors[o]}));break;case'sphere':objMesh=new THREE.Mesh(new THREE.SphereGeometry(0.42,16,16),new THREE.MeshStandardMaterial({color:objColors[o]}));break;case'cylinder':objMesh=new THREE.Mesh(new THREE.CylinderGeometry(0.34,0.34,0.85,12),new THREE.MeshStandardMaterial({color:objColors[o]}));break;}if(objMesh)objMesh.position.set((x-gridSize/2)*tileSize,h*0.61+0.5,(y-gridSize/2)*tileSize),groundGroup.add(objMesh)}}scene.add(groundGroup);function getHeightAt(x,z){const fx=(x+gridSize/2)/tileSize,fy=(z+gridSize/2)/tileSize;const ix=Math.round(fx),iy=Math.round(fy);if(ix>=0&&ix<gridSize&&iy>=0&&iy<gridSize)return heights[iy][ix]*0.61+PLAYER_HEIGHT;return PLAYER_HEIGHT}let prevRightX=0,prevRightY=0,prevLeftX=0,snapActive=false;renderer.xr.addEventListener("sessionstart",()=>{const session=renderer.xr.getSession();session.addEventListener('inputsourceschange',()=>{});});function handleVRInput(){const session=renderer.xr.getSession();if(!session)return;for(const s of session.inputSources){if(!s.gamepad)continue;const g=s.gamepad,axes=g.axes;let isLeft=s.handedness==='left',isRight=s.handedness==='right';if(!isLeft&&!isRight&&session.inputSources.length===1)isLeft=true;const turnVal=axes[2]||axes[0]||0,moveValY=axes[3]||axes[1]||0,moveValX=axes[0]||0;if(isRight){if(Math.abs(moveValY)>0.1||Math.abs(moveValX)>0.1){let speed=0.06;const moveForward=moveValY*speed,moveRight=moveValX*speed;const angle=playerAngle;playerPos.x+=Math.sin(angle)*moveForward+Math.cos(angle)*moveRight;playerPos.z+=Math.cos(angle)*moveForward-Math.sin(angle)*moveRight;}}if(isLeft){if(Math.abs(turnVal)>0.4&&!snapActive){const snapAngle=THREE.MathUtils.degToRad(30);playerAngle+=turnVal>0?snapAngle:-snapAngle;snapActive=true;}if(Math.abs(turnVal)<=0.2)snapActive=false;}}playerPos.y=getHeightAt(playerPos.x,playerPos.z);camera.position.copy(playerPos);camera.position.y=playerPos.y;camera.rotation.y=playerAngle;}window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)});renderer.setAnimationLoop(()=>{handleVRInput();renderer.render(scene,camera)});</script></body></html>
```
