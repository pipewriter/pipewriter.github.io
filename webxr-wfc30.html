
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);scene.add(camera);const gridSize=16,tileSize=1.5,heightLevels=8,baseHeight=0.25,tiles=[],heightColors=[0x8ED6FF,0x91E771,0xFFD57E,0xCEB2FF,0xFE9AB6,0xE7CFE3,0xB0B8DC,0xAAAAAA],objectColors=[0xffffff,0xff4444,0x44ff44,0x4444ff,0xffff44,0xff44ff,0x44ffff],primitiveGeoms=['none','box','sphere','cone','cylinder'];const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(0,5,4),scene.add(light);scene.add(new THREE.AmbientLight(0xffffff,0.25));function allowed(t,c){return[(t+c)%heightLevels,(t+1+c)%heightLevels,(t-1+heightLevels+c)%heightLevels]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapse(poss,allowedFn,levels=heightLevels,guardMul=20){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*guardMul;){guard++;let min=99,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min===99){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let p=poss[ny][nx];if(p.length>1){const allowedSet=allowedFn(tile);p=p.filter(v=>allowedSet.includes(v));0===p.length&&(p=[Math.random()*levels|0]);if(p.length!==poss[ny][nx].length)poss[ny][nx]=p,queue.push([nx,ny]);}}}}}function generateWFC(levels,allowedFn){const poss=[];for(let y=0;y<gridSize;y++){poss[y]=[];for(let x=0;x<gridSize;x++)poss[y][x]=Array.from({length:levels},(_,i)=>i);}collapse(poss,allowedFn,levels);return poss.map(row=>row.map(cell=>cell[0]))}const heightMap=generateWFC(heightLevels,t=>([(t)%heightLevels,(t+1)%heightLevels,(t+heightLevels-1)%heightLevels])),objectMap=generateWFC(primitiveGeoms.length,t=>([(t)%primitiveGeoms.length,(t+1)%primitiveGeoms.length,(t+primitiveGeoms.length-1)%primitiveGeoms.length]));const tileMeshes=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const h=heightMap[y][x],col=heightColors[h%heightColors.length],height=baseHeight+h*0.6;const tile=new THREE.Mesh(new THREE.BoxGeometry(tileSize,height,tileSize),new THREE.MeshStandardMaterial({color:col,vertexColors:!1}));tile.position.set((x-gridSize/2)*tileSize,height/2,(y-gridSize/2)*tileSize);scene.add(tile);tileMeshes.push({x,y,mesh:tile,h});const objectType=objectMap[y][x];if(objectType>0){let geom,mat,newObjColor=objectColors[(objectType+h)%objectColors.length];switch(primitiveGeoms[objectType]){case'box':geom=new THREE.BoxGeometry(0.7,0.7,0.7);break;case'sphere':geom=new THREE.SphereGeometry(0.38,12,12);break;case'cone':geom=new THREE.ConeGeometry(0.33,0.8,12);break;case'cylinder':geom=new THREE.CylinderGeometry(0.25,0.25,0.68,12);break;}if(geom){mat=new THREE.MeshStandardMaterial({color:newObjColor});const pmesh=new THREE.Mesh(geom,mat);pmesh.position.set((x-gridSize/2)*tileSize,height+0.4,(y-gridSize/2)*tileSize);scene.add(pmesh)}}}function findGroundY(x,z){let bx=Math.round(x/tileSize+gridSize/2),bz=Math.round(z/tileSize+gridSize/2);if(bx<0)bx=0;if(bx>=gridSize)bx=gridSize-1;if(bz<0)bz=0;if(bz>=gridSize)bz=gridSize-1;const h=heightMap[bz][bx];return baseHeight/2+h*0.6/2+0.7}let cameraRig=new THREE.Group;cameraRig.position.copy(new THREE.Vector3(0,findGroundY(0,0)+1.5,0));cameraRig.add(camera);scene.add(cameraRig);let teleportDir=null,rotating=!1,rotationQueued=0;const controllers=[renderer.xr.getController(0),renderer.xr.getController(1)];controllers.forEach(c=>scene.add(c));let leftController=controllers[0],rightController=controllers[1],gamepads={};renderer.xr.addEventListener('sessionstart',()=>{controllers.forEach((c,i)=>{c.addEventListener('connected',e=>{if(!gamepads[i])gamepads[i]=e.data.gamepad});c.addEventListener('disconnected',e=>{gamepads[i]=null});});});function deadzone(x,tol=0.12){return Math.abs(x)>tol?x:0}function updateVRMove(){let rigSpd=0.08,rotSnapRad=Math.PI/8;if(!renderer.xr.isPresenting)return;for(let i=0;i<controllers.length;i++){let gp=gamepads[i];if(!gp)continue;let axes=gp.axes;let isLeft=i==0;let isRight=!isLeft;if(isRight){let dx=deadzone(axes[2]||0),dz=-deadzone(axes[3]||0);if(dx||dz){let dir=new THREE.Vector3(dx,0,dz);let q=new THREE.Quaternion;cameraRig.getWorldQuaternion(q);dir.applyQuaternion(q).setY(0).normalize().multiplyScalar(rigSpd);cameraRig.position.add(dir);}}if(isLeft&&!rotating){let rx=deadzone(axes[2]||0);if(Math.abs(rx)>0.75){rotating=!0;rotationQueued=rx>0?1:-1;}else rotating=!1;}}if(rotating&&rotationQueued!==0){cameraRig.rotation.y-=rotationQueued*rotSnapRad;rotationQueued=0;setTimeout(()=>rotating=!1,210);}let y=findGroundY(cameraRig.position.x,cameraRig.position.z)+1.45;cameraRig.position.y+=0.2*(y-cameraRig.position.y);}renderer.setAnimationLoop(()=>{updateVRMove();renderer.render(scene,camera);});window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});</script></body></html>
