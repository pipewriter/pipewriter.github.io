
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const HEAD_HEIGHT=1.7;let playerPos=new THREE.Vector3(0,0,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);const gridSize=16,tileSize=1.5,tileCount=7,heightCount=4,colors=[16711680,65280,255,16776960,16711935,65535,16777215],heightColors=[4473924,26367,16775930,16777164],tiles=[],geoms=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i],vertexColors:!0});tiles.push({geom:g,mat:m})}const possibleHeights=[0,1,2,3],mapH=[],mapT=[];function allowed(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function allowedH(h){return[h,Math.max(0,h-1),Math.min(heightCount-1,h+1)]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function genWFC(possArr,count,adjF){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=999,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=possArr[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(999===min){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=possArr[cy][cx],pick=options[Math.random()*options.length|0];possArr[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),t=possArr[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=possArr[ny][nx];if(poss.length>1){const allowedSet=adjF(t);if(poss=poss.filter(v=>allowedSet.includes(v)),poss.length==0&&(poss=[Math.random()*count|0]),poss.length!==possArr[ny][nx].length){possArr[ny][nx]=poss,queue.push([nx,ny])}}}}}}for(let y=0;y<gridSize;y++)mapH[y]=[],mapT[y]=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++)mapH[y][x]=possibleHeights.slice(),mapT[y][x]=[0,1,2,3,4,5,6];genWFC(mapH,heightCount,allowedH);genWFC(mapT,tileCount,allowed);const primitiveColors=[0,65280,255,16711680,0xffffff,0x111111],primTypes=["none","cube","sphere","cylinder","cone"],prims=[];for(let i=0;i<primTypes.length;i++){let g=null;if(i==1)g=new THREE.BoxGeometry(.8*tileSize,.8*tileSize,.8*tileSize);else if(i==2)g=new THREE.SphereGeometry(.4*tileSize,12,12);else if(i==3)g=new THREE.CylinderGeometry(.35*tileSize,.35*tileSize,.8*tileSize,16);else if(i==4)g=new THREE.ConeGeometry(.38*tileSize,.8*tileSize,16);prims.push(g)}function pickPrimitive(){return Math.random()<.63?0:1+((Math.random()*4)|0)}for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const tIdx=mapT[y][x][0],hIdx=mapH[y][x][0],mesh=new THREE.Mesh(tiles[tIdx].geom,tiles[tIdx].mat.clone());mesh.position.set((x-gridSize/2)*tileSize,hIdx*tileSize/2,(y-gridSize/2)*tileSize),mesh.scale.y=1+hIdx/2;mesh.material=mesh.material.clone();mesh.material.color.setHex(colors[tIdx]);mesh.material.vertexColors=!0;const c=new THREE.Color(heightColors[hIdx]);const attr=mesh.geometry.attributes.position,count=attr.count,colorsArr=[];for(let j=0;j<count;j++)colorsArr.push(c.r,c.g,c.b);mesh.geometry.setAttribute("color",new THREE.Float32BufferAttribute(colorsArr,3));scene.add(mesh);if(pickPrimitive()){const ptype=pickPrimitive(),geo=prims[ptype];if(geo){const o=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:primitiveColors[ptype]}));o.position.copy(mesh.position);o.position.y+=tileSize*0.55+0.41*hIdx;o.castShadow=o.receiveShadow=!0;scene.add(o)}}}const controllerData=[null,null];function handleController(ctrl,hand){if(!ctrl)return;ctrl.addEventListener('connected',e=>{controllerData[hand]={ctrl:ctrl,axes:new Array(4).fill(0),id:0,ready:!0}});ctrl.addEventListener('disconnected',e=>{controllerData[hand]=null});}handleController(renderer.xr.getController(0),0);handleController(renderer.xr.getController(1),1);let lastRot=0;function updateControllers(){for(let i=0;i<2;i++){const d=controllerData[i];if(!d||!d.ctrl||!d.ctrl.gamepad)continue;const axes=d.ctrl.gamepad.axes||[];const lx=axes[2]||axes[0]||0,ly=axes[3]||axes[1]||0,rx=axes[0]||0,ry=axes[1]||0;let vec=new THREE.Vector3();if(i==0){if(Math.abs(lx)>.22||Math.abs(ly)>.22){let rot=-camera.rotation.y;vec.set(lx,0,ly).applyAxisAngle(new THREE.Vector3(0,1,0),rot);playerPos.add(vec.multiplyScalar(.14*tileSize));}}if(i==1){if(Math.abs(rx)>.6&&performance.now()-lastRot>260){const sign=Math.sign(rx);camera.rotation.y-=sign*Math.PI/6,lastRot=performance.now();}}}}renderer.setAnimationLoop(()=>{updateControllers();camera.position.set(playerPos.x,HEAD_HEIGHT+getGround(playerPos.x,playerPos.z),playerPos.z);renderer.render(scene,camera)});function getGround(x,z){let gx=Math.round(x/tileSize+gridSize/2),gz=Math.round(z/tileSize+gridSize/2);if(gx<0||gx>=gridSize||gz<0||gz>=gridSize)return 0;return (mapH[gz][gx]?mapH[gz][gx][0]:0)*tileSize/2}</script></body></html>
