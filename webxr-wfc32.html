
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR Expanded</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3),player=new THREE.Object3D;scene.add(player);player.add(camera);let camY=2.2;const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,10,0);scene.add(light);const gridSize=20,tileSize=2.2,groundColors=[0x5e3c18,0x47ad39,0xc2b280,0x638ac6],groundCount=groundColors.length,htMin=0,htMax=9,htRange=htMax-htMin+1,heightPoss=[],objectPoss=[];for(let y=0;y<gridSize;y++){heightPoss[y]=[],objectPoss[y]=[];for(let x=0;x<gridSize;x++)heightPoss[y][x]=[...Array(htRange).keys()].map(v=>v+htMin),objectPoss[y][x]=[0,1,2,3,4]}function hn(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(([a,b])=>a>=0&&a<gridSize&&b>=0&&b<gridSize)}function allowedh(h){return[h,Math.max(htMin,h-1),Math.min(htMax,h+1)].filter((v,i,a)=>a.indexOf(v)===i&&v>=htMin&&v<=htMax)}function allowedo(id){if(id===0)return[0,1,2,3,4];if(id===3)return[0,3];return[0,id]}function collapseWFC(poss,allowed){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=999,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const l=poss[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min>=999){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],opts=poss[cy][cx],pick=opts[Math.random()*opts.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),val=poss[qy][qx][0];for(const[nx,ny]of hn(qx,qy)){let possN=poss[ny][nx];if(possN.length>1){const allowSet=allowed(val);possN=possN.filter(v=>allowSet.includes(v));0===possN.length&&(possN=[allowSet[Math.random()*allowSet.length|0]]);if(possN.length!==poss[ny][nx].length){poss[ny][nx]=possN;queue.push([nx,ny])}}}}}}collapseWFC(heightPoss,allowedh);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++)objectPoss[y][x]=[0,1,2,3,4];collapseWFC(objectPoss,allowedo);const objectShapes=[null,new THREE.Mesh(new THREE.ConeGeometry(.65,.8,5),new THREE.MeshStandardMaterial({color:0xb41c1c})),new THREE.Mesh(new THREE.BoxGeometry(.9,.65,.5),new THREE.MeshStandardMaterial({color:0x4b63b2})),new THREE.Mesh(new THREE.CylinderGeometry(.36,.36,.7,8),new THREE.MeshStandardMaterial({color:0x3ab21f})),new THREE.Mesh(new THREE.DodecahedronGeometry(.43),new THREE.MeshStandardMaterial({color:0xf7ad23}))],gGeoms=[],tileMeshes=[];for(let h=htMin;h<=htMax;h++){let cidx=Math.floor((h-htMin)/(htRange)*groundCount)%groundCount;let c=groundColors[cidx];let g=new THREE.PlaneGeometry(tileSize,tileSize,1,1);g.rotateX(-Math.PI/2);gGeoms.push([g,new THREE.MeshStandardMaterial({color:c,vertexColors:!0})])}for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const h=heightPoss[y][x][0],gIdx=h-htMin,[g,mat]=gGeoms[gIdx],tile=new THREE.Mesh(g,mat.clone());tile.receiveShadow=!0;tile.position.set((x-gridSize/2)*tileSize,h*.5,(y-gridSize/2)*tileSize);let col=new THREE.Color(groundColors[gIdx]).multiplyScalar(.89+.1*(h-htMin)/htRange);tile.material=tile.material.clone();tile.material.color=col;scene.add(tile);tileMeshes.push(tile);const oid=objectPoss[y][x][0],oShape=objectShapes[oid]?objectShapes[oid].clone():null;if(oShape){oShape.position.set(tile.position.x,h*1+.49,tile.position.z);oShape.castShadow=!0;scene.add(oShape)}}let joyL={x:0,y:0},joyR={x:0,y:0},move={x:0,y:0},moveTarget={x:0,y:0};let snapBuffer=0,snapCooldown=0;function lerp(a,b,t){return a+(b-a)*t}renderer.xr.addEventListener("sessionstart",()=>{const session=renderer.xr.getSession();session.addEventListener("inputsourceschange",()=>{});});function handlePads(){const inputSources=renderer.xr.getSession()?Array.from(renderer.xr.getSession().inputSources):[];for(const source of inputSources){if(!source.gamepad)continue;const gp=source.gamepad;if(gp.axes.length>=4){[joyL.x,joyL.y,joyR.x,joyR.y]=gp.axes}}}function doMove(delta){moveTarget.x=-joyR.x*delta*9;moveTarget.y=-joyR.y*delta*9;move.x=lerp(move.x,moveTarget.x,.16);move.y=lerp(move.y,moveTarget.y,.16);const ang=player.rotation.y;player.position.x+=Math.sin(ang)*move.y+Math.cos(ang)*move.x;player.position.z+=Math.cos(ang)*move.y-Math.sin(ang)*move.x}function doSnap(){if(Math.abs(joyL.x)>.6&&snapBuffer<=0){let d=joyL.x<0?-1:1;player.rotation.y+=Math.PI/4*d;snapBuffer=30}else snapBuffer=Math.max(0,snapBuffer-1)}function fixHeight(){let gx=Math.round(player.position.x/tileSize+gridSize/2),gz=Math.round(player.position.z/tileSize+gridSize/2);gx=Math.max(0,Math.min(gridSize-1,gx));gz=Math.max(0,Math.min(gridSize-1,gz));const h=heightPoss[gz][gx][0];player.position.y=camY+h*.5}renderer.setAnimationLoop((dt)=>{handlePads();doMove(dt?dt/1000:0.016);doSnap();fixHeight();renderer.render(scene,camera)});window.addEventListener("resize",()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});</script></body></html>
