
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);scene.add(camera);let light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);let gridSize=20,tileSize=1.5,tiles=[],heights=[.3,2,4,6],heightColors=[16711680,65280,255,16777215],heightTileCount=4,objectTileCount=5,objectColors=[0,16711935,16776960,65535,16711680],objectPrimitives=['none','box','sphere','cylinder','cone'],groundMeshes=[],objectMeshes=[],heightMap=[],objectMap=[],UP_VEC=new THREE.Vector3(0,1,0),playerY=.7,playerOffset=new THREE.Vector3(0,playerY,0);for(let i=0;i<heightTileCount;i++){let g=new THREE.BoxGeometry(tileSize,.3*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:heightColors[i]});tiles.push(new THREE.Mesh(g,m))}let allowedH=t=>[t,(t+1)%heightTileCount,(t+heightTileCount-1)%heightTileCount],neighbors=(x,y)=>[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize),collapseWFC=function(tileCt,allowedFn){let m=[];for(let y=0;y<gridSize;y++){m[y]=[];for(let x=0;x<gridSize;x++)m[y][x]=[];for(let x=0;x<gridSize;x++)m[y][x]=Array.from(Array(tileCt).keys())}let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*20;){guard++;let min=99,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let l=m[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min===99){unresolved=!1;break}let[rx,ry]=choices[Math.random()*choices.length|0],ops=m[ry][rx],pick=ops[Math.random()*ops.length|0];m[ry][rx]=[pick];let queue=[[rx,ry]];for(;queue.length;){let[qx,qy]=queue.shift(),tile=m[qy][qx][0];for(let[nx,ny]of neighbors(qx,qy)){let poss=m[ny][nx];if(poss.length>1){let allow=allowedFn(tile);if(poss=poss.filter(v=>allow.includes(v)),poss.length===0)poss=[Math.random()*tileCt|0];if(poss.length!==m[ny][nx].length)m[ny][nx]=poss,queue.push([nx,ny])}}}}return m};let hMap=collapseWFC(heightTileCount,allowedH);for(let y=0;y<gridSize;y++){heightMap[y]=[];for(let x=0;x<gridSize;x++){let hidx=hMap[y][x][0];heightMap[y][x]=hidx}}let allowedO=t=>objectPrimitives[0]==='none'?[0,1,2,3,4]:[1,2,3,4],oMap=collapseWFC(objectTileCount,t=>allowedO(t));for(let y=0;y<gridSize;y++){objectMap[y]=[];for(let x=0;x<gridSize;x++){let oidx=oMap[y][x][0];objectMap[y][x]=oidx}}function createPrimitive(type,color){if(type==='none')return null;let g,m;if(type==='box')g=new THREE.BoxGeometry(.8,.8,.8);else if(type==='sphere')g=new THREE.SphereGeometry(.48,12,12);else if(type==='cylinder')g=new THREE.CylinderGeometry(.4,.4,.8,12);else if(type==='cone')g=new THREE.ConeGeometry(.4,.8,12);else return null;m=new THREE.MeshStandardMaterial({color});let mesh=new THREE.Mesh(g,m);return mesh}for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let hi=heightMap[y][x],h=heights[hi],hc=heightColors[hi],base=tiles[hi].clone();base.position.set((x-gridSize/2)*tileSize,h*.5,(y-gridSize/2)*tileSize);base.scale.y=h/tileSize;base.material=new THREE.MeshStandardMaterial({color:hc});scene.add(base),groundMeshes.push(base);let oi=objectMap[y][x];if(oi>0){let prim=createPrimitive(objectPrimitives[oi],objectColors[oi]);if(prim){prim.position.set(base.position.x,h+.45,(base.position.z));scene.add(prim),objectMeshes.push(prim)}}}let userRig=new THREE.Group();userRig.add(camera);scene.add(userRig);function getHeightAt(x,z){let gx=Math.floor(x/tileSize+gridSize/2),gy=Math.floor(z/tileSize+gridSize/2);if(gx<0||gx>=gridSize||gy<0||gy>=gridSize)return 0;let hi=heightMap[gy][gx],h=heights[hi];return h}function clamp(v,min,max){return v<min?min:v>max?max:v}let speed=0.04,rotSnap=Math.PI/6,controllerData=[{},{}];renderer.xr.addEventListener("sessionstart",()=>{let s=renderer.xr.getSession(),inputSources=s.inputSources;for(let i=0;i<2;i++){controllerData[i]={axes:[0,0],lastAxes:[0,0],snapCooldown:0};}});renderer.setAnimationLoop(()=>{let session=renderer.xr.getSession();if(session){let inputSources=session.inputSources;for(let i=0;i<2;i++){let input=inputSources[i];if(input&&input.gamepad){let cd=controllerData[i],axes=input.gamepad.axes;cd.lastAxes=cd.axes.slice();cd.axes=[axes[0]||0,axes[1]||0];}}let move=controllerData[1];if(move){let dx=move.axes[0],dz=move.axes[1];let dir=new THREE.Vector3();camera.getWorldDirection(dir);dir.y=0;dir.normalize();let strafe=new THREE.Vector3().crossVectors(UP_VEC,dir).normalize();let mv=new THREE.Vector3();mv.addScaledVector(dir,-dz*speed);mv.addScaledVector(strafe,dx*speed);userRig.position.add(mv)}let rotate=controllerData[0];if(rotate){let lx=rotate.axes[0];if(Math.abs(lx)>.6&&rotate.snapCooldown<=0){userRig.rotation.y-=Math.sign(lx)*rotSnap;rotate.snapCooldown=20}else if(Math.abs(lx)<=.3){rotate.snapCooldown=0}if(rotate.snapCooldown>0)rotate.snapCooldown--}}let px=userRig.position.x,pz=userRig.position.z,py=playerY+getHeightAt(px,pz);userRig.position.y=py;renderer.render(scene,camera)});window.addEventListener("resize",()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});</script></body></html>
```
