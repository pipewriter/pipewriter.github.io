
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:true});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=true;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.1,1e3);camera.position.set(0,10,0);const player={obj:new THREE.Object3D(),velocity:new THREE.Vector3(),yaw:0,height:2,speed:0.07,turnSpeed:Math.PI/8};scene.add(player.obj);player.obj.add(camera);const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(0,1,1);scene.add(light);const gridSize=20,tileSize=2,tileCount=7,colors=[0xff0000,0x00ff00,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xffffff],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,0.18*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}const heightCount=6,heightColors=[0x325432,0x77aa44,0xddddaa,0xaaffee,0xbbbbff,0x3860a3];const objectList=[null,"cube","sphere","cylinder"],objectColors=[0x000000,0xffffff,0x0033cc,0xcc6600];function makeObj(type){if(type==="cube"){return new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5),new THREE.MeshStandardMaterial({color:objectColors[1]}))}if(type==="sphere"){return new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16),new THREE.MeshStandardMaterial({color:objectColors[2]}))}if(type==="cylinder"){return new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.25,0.7,16),new THREE.MeshStandardMaterial({color:objectColors[3]}))}return null}function allowed(idx,max){return[idx,(idx+1)%max,(idx+max-1)%max]}function neighbors(x,y,gs){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gs&&p[1]>=0&&p[1]<gs)}function wfc2d(size,tileCt,allowfn){let possibles=[];for(let y=0;y<size;y++){possibles[y]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[];for(let x=0;x<size;x++)possibles[y][x]=[(function(){let arr=[];for(let i=0;i<tileCt;i++)arr.push(i);return arr})()]}return possibles}function collapseWFC(possibles,size,tileCt,allowfn){let unresolved=true,guard=0;while(unresolved&&guard<size*size*10){guard++;let min=tileCt+1,choices=[];for(let y=0;y<size;y++)for(let x=0;x<size;x++){const len=possibles[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min>tileCt){unresolved=false;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=possibles[cy][cx],pick=options[Math.random()*options.length|0];possibles[cy][cx]=[pick];const queue=[[cx,cy]];while(queue.length){const[qx,qy]=queue.shift(),tileI=possibles[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy,size)){let poss=possibles[ny][nx];if(poss.length>1){const allowedSet=allowfn(tileI);let newPoss=poss.filter(v=>allowedSet.includes(v));if(newPoss.length===0)newPoss=[Math.random()*tileCt|0];if(newPoss.length!==poss.length){possibles[ny][nx]=newPoss,queue.push([nx,ny])}}}}}}function flattenWFC(p,size){let f=[];for(let y=0;y<size;y++)for(let x=0;x<size;x++)f.push(p[y][x][0]);return f}let heightPoss=wfc2d(gridSize,heightCount,(t)=>allowed(t,heightCount)),objectPoss=wfc2d(gridSize,objectList.length,(t)=>allowed(t,objectList.length));collapseWFC(heightPoss,gridSize,heightCount,(t)=>allowed(t,heightCount));collapseWFC(objectPoss,gridSize,objectList.length,(t)=>allowed(t,objectList.length));for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const heightIdx=heightPoss[y][x][0],tileIdx=heightIdx%tileCount,objIdx=objectPoss[y][x][0];const base=tiles[tileIdx].clone();const h=heightIdx;const vColor=heightColors[heightIdx];base.position.set((x-gridSize/2)*tileSize,0,(y-gridSize/2)*tileSize);base.material=base.material.clone();base.material.color.setHex(vColor);scene.add(base);if(objIdx>0){const obj=makeObj(objectList[objIdx]);if(obj)obj.position.set((x-gridSize/2)*tileSize,0.25*tileSize,(y-gridSize/2)*tileSize),scene.add(obj)}}function getHeightAt(x,z){let fx=Math.round(x/tileSize+gridSize/2),fz=Math.round(z/tileSize+gridSize/2);if(fx<0)fx=0;if(fz<0)fz=0;if(fx>=gridSize)fx=gridSize-1;if(fz>=gridSize)fz=gridSize-1;const hIdx=heightPoss[fz][fx][0];return 0.5*tileSize+(hIdx-1)*0.22*tileSize}let prevXR=false,leftStickPrev=0,rightStickPrev=0;renderer.xr.addEventListener("sessionstart",()=>{prevXR=true});renderer.xr.addEventListener("sessionend",()=>{prevXR=false});function handleGamepads(){const ses=renderer.xr.getSession();if(!ses)return;const pads=Array.from(navigator.getGamepads()).filter(Boolean);for(const gp of pads){if(!gp||!gp.axes)return;let lsx=gp.axes[2],lsy=gp.axes[3],rsx=gp.axes[0],rsy=gp.axes[1];if(Math.abs(lsy)>0.15){let move=new THREE.Vector3(0,0,-lsy*player.speed);move.applyAxisAngle(new THREE.Vector3(0,1,0),player.yaw);player.obj.position.add(move)}if(Math.abs(lsx)>0.15){let move=new THREE.Vector3(lsx*player.speed,0,0);move.applyAxisAngle(new THREE.Vector3(0,1,0),player.yaw);player.obj.position.add(move)}if(Math.abs(rsx)>0.5&&rightStickPrev===0){player.yaw+=rsx>0?player.turnSpeed:-player.turnSpeed;rightStickPrev=rsx}else if(Math.abs(rsx)<=0.5)rightStickPrev=0;}let px=player.obj.position.x,pz=player.obj.position.z,h=getHeightAt(px,pz);player.obj.position.y=h+player.height}renderer.setAnimationLoop(()=>{if(renderer.xr.isPresenting)handleGamepads();renderer.render(scene,camera)});window.addEventListener("resize",()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)});</script></body></html>
```
