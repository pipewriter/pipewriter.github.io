
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden;}</style></head><body><script type="module">import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';import { VRButton } from 'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:true});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=true;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.1,1000);let camY=3;camera.position.set(0,camY,0);const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(0,1,0);scene.add(light);const gridSize=16,tileSize=1.5,heightTiles=7,objTiles=5,heightColors=[0x38b000,0x70e000,0xd9ed92,0xe9c46a,0xf77f00,0xd62828,0x22223b],tiles=[];for(let i=0;i<heightTiles;i++){const g=new THREE.BoxGeometry(tileSize,0.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:heightColors[i]});tiles.push(new THREE.Mesh(g,m));}const objColors=[0xffffff,0x189ab4,0xffb703,0x8338ec,0x000000],prims=[null,()=>{const m=new THREE.MeshStandardMaterial({color:objColors[1]});return new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5),m)},()=>{const m=new THREE.MeshStandardMaterial({color:objColors[2]});return new THREE.Mesh(new THREE.SphereGeometry(0.28,12,8),m)},()=>{const m=new THREE.MeshStandardMaterial({color:objColors[3]});return new THREE.Mesh(new THREE.ConeGeometry(0.27,0.5,10),m)},()=>{const m=new THREE.MeshStandardMaterial({color:objColors[4]});return new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.5,10),m)},];function allowedH(t){return [t,(t+1)%heightTiles,(t+heightTiles-1)%heightTiles];}function nbs(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(v=>v[0]>=0&&v[0]<gridSize&&v[1]>=0&&v[1]<gridSize);}function collapsePoss(tilecount,allowedfn){let p=[];for(let y=0;y<gridSize;y++){p[y]=[];for(let x=0;x<gridSize;x++)p[y][x]=Array(tilecount).fill(0).map((_,i)=>i);}let done=0;let unresolved=true,guard=0;while(unresolved&&guard<gridSize*gridSize*18){guard++;let min=1e9,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const l=p[y][x].length;if(l>1&&l<min){min=l,choices=[[x,y]];}else if(l==min)choices.push([x,y]);}if(choices.length==0){unresolved=false;break;}const[ccx,ccy]=choices[Math.random()*choices.length|0],opts=p[ccy][ccx],pick=opts[Math.random()*opts.length|0];p[ccy][ccx]=[pick];const queue=[[ccx,ccy]];while(queue.length){const[qx,qy]=queue.shift(),tile=p[qy][qx][0];for(const[nx,ny]of nbs(qx,qy)){let poss=p[ny][nx];if(poss.length>1){const allow=allowedfn(tile);poss=poss.filter(v=>allow.includes(v));if(!poss.length)poss=[Math.random()*tilecount|0];if(poss.length!=p[ny][nx].length){p[ny][nx]=poss;queue.push([nx,ny]);}}}}}return p;}const hposs=collapsePoss(heightTiles,allowedH),objposs2d=[];for(let y=0;y<gridSize;y++){objposs2d[y]=[];for(let x=0;x<gridSize;x++){objposs2d[y][x]=[0,1,2,3,4];}}function allowedObj(t){if(t==0)return[0,1,2,3,4];return[0];}// 0: nothing, else: primitive at position. function collapseObj(){let unresolved=true,guard=0;while(unresolved&&guard<gridSize*gridSize*12){guard++;let min=1e9,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const l=objposs2d[y][x].length;if(l>1&&l<min){min=l,choices=[[x,y]];}else if(l==min)choices.push([x,y]);}if(choices.length==0){unresolved=false;break;}const[cx,cy]=choices[Math.random()*choices.length|0],opts=objposs2d[cy][cx],pick=opts[Math.random()*opts.length|0];objposs2d[cy][cx]=[pick];const queue=[[cx,cy]];while(queue.length){const[qx,qy]=queue.shift(),tile=objposs2d[qy][qx][0];for(const[nx,ny]of nbs(qx,qy)){let poss=objposs2d[ny][nx];if(poss.length>1){const allow=allowedObj(tile);poss=poss.filter(v=>allow.includes(v));if(!poss.length)poss=[0];if(poss.length!=objposs2d[ny][nx].length){objposs2d[ny][nx]=poss;queue.push([nx,ny]);}}}}}}collapseObj();const minH=1,maxH=4.1,yy=[],meshes=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const hi=hposs[y][x][0],tile=tiles[hi].clone();const htl=THREE.MathUtils.lerp(minH,maxH,hi/(heightTiles-1));tile.scale.y=htl;tile.position.set((x-gridSize/2)*tileSize,htl*0.075,(y-gridSize/2)*tileSize);tile.material=new THREE.MeshStandardMaterial({color:heightColors[hi],vertexColors:false});scene.add(tile);meshes.push(tile);yy.push(tile.position.y+tileSize*htl*0.5);const obi=objposs2d[y][x][0];if(obi==0)continue;const ob=prims[obi]();ob.position.set((x-gridSize/2)*tileSize,htl*0.15+0.36,(y-gridSize/2)*tileSize);scene.add(ob);}function snapRad(r){return Math.round(r/(Math.PI/6))*(Math.PI/6);}let moveVel=new THREE.Vector3(),rotDir=0,snapTarget=0,lastLx=0;const speed=2;renderer.xr.addEventListener('sessionstart',()=>{let user=renderer.xr.getCamera(camera);const rig=user;renderer.setAnimationLoop(()=>{let session=renderer.xr.getSession();if(session){let input=Array.from(session.inputSources).find(s=>s&&s.gamepad&&s.handedness);let rinput=Array.from(session.inputSources).find(s=>s&&s.gamepad&&s.handedness==='right');let linput=Array.from(session.inputSources).find(s=>s&&s.gamepad&&s.handedness==='left');if(rinput&&rinput.gamepad){let axes=rinput.gamepad.axes;let mx=axes[2]||0,mz=axes[3]||0;if(Math.abs(mx)+Math.abs(mz)>0.18){let dir=new THREE.Vector3(mx,0,mz).normalize().multiplyScalar(speed*0.03);let yrot=camera.rotation.y;let mtx=new THREE.Matrix4().makeRotationY(yrot||0);dir.applyMatrix4(mtx);moveVel.x=dir.x;moveVel.z=dir.z;}else{moveVel.x=moveVel.z=0;}}if(linput&&linput.gamepad){let axes=linput.gamepad.axes,rx=axes[2]||0;if(Math.abs(rx)>0.25&&Math.abs(lastLx)<0.25){rotDir=rx>0?1:-1;snapTarget=camera.rotation.y+(rotDir*Math.PI/6);}else if(Math.abs(rx)<=0.25){rotDir=0;}lastLx=rx;}}if(snapTarget!==0){camera.rotation.y=snapRad(snapTarget);snapTarget=0;}}let np=new THREE.Vector3(camera.position.x+moveVel.x,0,camera.position.z+moveVel.z);let gx=Math.round((np.x/tileSize)+gridSize/2),gy=Math.round((np.z/tileSize)+gridSize/2);gx=Math.max(0,Math.min(gridSize-1,gx));gy=Math.max(0,Math.min(gridSize-1,gy));let h=Math.max(camY,yy[gy*gridSize+gx]||camY);camera.position.x=np.x;camera.position.z=np.z;camera.position.y=h+camY;renderer.render(scene,camera);});});window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});</script></body></html>
```
