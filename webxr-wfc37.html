
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import * as THREE from "https://unpkg.com/three@0.157.0/build/three.module.js";import {VRButton} from "https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js";const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);scene.add(camera);let userRoot=new THREE.Group();scene.add(userRoot);userRoot.add(camera);camera.position.set(0,1.7,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);const gridSize=16,tileSize=1.5,surfaceCount=7,surfaceColors=[16711680,65280,255,16776960,16711935,65535,16777215],surfaces=[],maxHeight=5,heightColors=[0x335599,0x337744,0x889922,0xa06f25,0xe5c973],heightCount=5,heightMap=[],objectTypes=["none","cube","sphere","cylinder","cone"],objectColors=[0x111111,0xffaaff,0x00eeee,0xffff7f,0xaaee55],objectMap=[],objectProb=[0.7,0.1,0.08,0.08,0.04];for(let i=0;i<surfaceCount;i++){const g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:surfaceColors[i]});surfaces.push(new THREE.Mesh(g,m))}const possibilities=[],allowed=(t)=>[t,(t+1)%surfaceCount,(t+surfaceCount-1)%surfaceCount],neighbors=(x,y)=>[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize),collapse=()=>{let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=8,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=possibilities[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(8===min){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=possibilities[cy][cx],pick=options[Math.random()*options.length|0];possibilities[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=possibilities[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=possibilities[ny][nx];if(poss.length>1){const allowedSet=allowed(tile);if(poss=poss.filter(v=>allowedSet.includes(v)),0===poss.length&&(poss=[Math.random()*surfaceCount|0]),poss.length!==possibilities[ny][nx].length){possibilities[ny][nx]=poss,queue.push([nx,ny])}}}}}}};for(let y=0;y<gridSize;y++){possibilities[y]=[];for(let x=0;x<gridSize;x++)possibilities[y][x]=[0,1,2,3,4,5,6]}collapse();for(let y=0;y<gridSize;y++){heightMap[y]=[];for(let x=0;x<gridSize;x++){heightMap[y][x]=[0,1,2,3,4]}}// 2nd WFC for height function allowedHeight(h){return[h,Math.max(0,h-1),Math.min(heightCount-1,h+1)]}function collapseHeight(){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=6,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=heightMap[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min===6){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=heightMap[cy][cx],pick=options[Math.random()*options.length|0];heightMap[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=heightMap[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=heightMap[ny][nx];if(poss.length>1){const allowedSet=allowedHeight(tile);poss=poss.filter(v=>allowedSet.includes(v));if(!poss.length)poss=[Math.random()*heightCount|0];if(poss.length!==heightMap[ny][nx].length){heightMap[ny][nx]=poss;queue.push([nx,ny])}}}}}}}collapseHeight();for(let y=0;y<gridSize;y++){objectMap[y]=[];for(let x=0;x<gridSize;x++){let pick="none",r=Math.random(),acc=0;for(let k=0;k<objectTypes.length;k++){acc+=objectProb[k];if(r<=acc){pick=objectTypes[k];break}}objectMap[y][x]=pick}}// Clear old meshes let allMeshes=[];function spawn(){for(const m of allMeshes)scene.remove(m);allMeshes.length=0;for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const sidx=possibilities[y][x][0],hidx=heightMap[y][x][0],h=hidx*0.65,surf=surfaces[sidx].clone();surf.position.set((x-gridSize/2)*tileSize,h,(y-gridSize/2)*tileSize);surf.material=surf.material.clone();surf.material.color.setHex(heightColors[hidx]);allMeshes.push(surf);scene.add(surf);const obj=objectMap[y][x];if(obj!=="none"){let mesh;if(obj==="cube"){mesh=new THREE.Mesh(new THREE.BoxGeometry(.5,.5,.5),new THREE.MeshStandardMaterial({color:objectColors[1]}))}else if(obj==="sphere"){mesh=new THREE.Mesh(new THREE.SphereGeometry(.32,16,16),new THREE.MeshStandardMaterial({color:objectColors[2]}))}else if(obj==="cylinder"){mesh=new THREE.Mesh(new THREE.CylinderGeometry(.22,.22,.6,16),new THREE.MeshStandardMaterial({color:objectColors[3]}))}else if(obj==="cone"){mesh=new THREE.Mesh(new THREE.ConeGeometry(.28,.6,16),new THREE.MeshStandardMaterial({color:objectColors[4]}))}if(mesh){mesh.position.copy(surf.position);mesh.position.y+=.4;allMeshes.push(mesh);scene.add(mesh)}}}}spawn();let controllerR,controllerL,rotSnapRad=Math.PI/6,rotTarget=0;function setupControllers(){renderer.xr.addEventListener("sessionstart",()=>{const s=renderer.xr.getSession(),srcs=s.inputSources.filter(o=>o.handedness==="right"),srcl=s.inputSources.filter(o=>o.handedness==="left");controllerR=renderer.xr.getController(0);controllerL=renderer.xr.getController(1);});}setupControllers();function lerp(a,b,t){return a+(b-a)*t}let moveX=0,moveY=0;renderer.xr.addEventListener('inputsourceschange',()=>{});function processGamepads(frame){const srcs=renderer.xr.getSession()?.inputSources||[];let lpad,rpad;for(let i=0;i<srcs.length;i++){const gp=srcs[i].gamepad;if(!gp)continue;if(srcs[i].handedness==="right")rpad=gp;if(srcs[i].handedness==="left")lpad=gp;}if(rpad){moveX=rpad.axes[2]||0;moveY=-(rpad.axes[3]||0);}if(lpad){const lx=lpad.axes[2]||0;if(Math.abs(lx)>0.7&&!rotateLock){rotTarget+=lx>0?rotSnapRad:-rotSnapRad;rotateLock=!0;rotateLockTimeout=20;}else if(Math.abs(lx)<.3){rotateLock=!1;}}}let rotateLock=!1,rotateLockTimeout=0;let rot=0,vel=new THREE.Vector3();renderer.setAnimationLoop((t)=>{if(renderer.xr.isPresenting){processGamepads();const speed=0.06;const forward=new THREE.Vector3(0,0,-1).applyQuaternion(userRoot.quaternion);const right=new THREE.Vector3(1,0,0).applyQuaternion(userRoot.quaternion);if(Math.abs(moveX)+Math.abs(moveY)>0.05){vel.copy(forward).multiplyScalar(moveY*speed).add(right.multiplyScalar(moveX*speed));userRoot.position.add(vel);}rot=lerp(rot,rotTarget,0.3);userRoot.rotation.y=rot;rotateLockTimeout=Math.max(0,rotateLockTimeout-1);if(!rotateLockTimeout)rotateLock=!1;// Clamp player height to above surface let px=userRoot.position.x/tileSize+gridSize/2,pz=userRoot.position.z/tileSize+gridSize/2,ix=Math.round(px),iz=Math.round(pz);if(ix>=0&&ix<gridSize&&iz>=0&&iz<gridSize){const h=heightMap[iz][ix][0]*0.65;userRoot.position.y=lerp(userRoot.position.y,h+1.7,0.6);}else userRoot.position.y=1.7;}renderer.render(scene,camera)});window.addEventListener("resize",()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});</script></body></html>
```
