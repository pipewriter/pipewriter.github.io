
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const PLAYER_HEIGHT=1.6;const gridSize=16,tileSize=2,tileCount=7,heightTileCount=5,heightColors=[0x97e47e,0xc3e2ac,0xb5dbc8,0xbed6ea,0xdedff8],tileColors=[0xff4444,0x44ff44,0x4444ff,0xffff44,0xff44ff,0x44ffff,0xffffff],tiles=[],heightTiles=[];function allowed(t,c){return[t,(t+1)%c,(t+c-1)%c]}function neighbors(x,y,s){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<s&&p[1]>=0&&p[1]<s)}function collapse(poss,c,allowedFn){let unresolved=!0,guard=0,s=poss.length;for(;unresolved&&guard<s*s*20;){guard++;let min=99,choices=[];for(let y=0;y<s;y++)for(let x=0;x<s;x++){const len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min>c){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy,s)){let p=poss[ny][nx];if(p.length>1){const allow=allowedFn(tile);if(p=p.filter(v=>allow.includes(v)),0===p.length&&(p=[Math.random()*c|0]),p.length!==poss[ny][nx].length){poss[ny][nx]=p,queue.push([nx,ny])}}}}}}for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.14*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:tileColors[i]});tiles.push(new THREE.Mesh(g,m))}for(let i=0;i<heightTileCount;i++){const g=new THREE.PlaneGeometry(tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:heightColors[i],vertexColors:!0,side:THREE.DoubleSide});heightTiles.push(new THREE.Mesh(g,m))}let heightPoss=[],objPoss=[],heightMap=[],objMap=[];for(let y=0;y<gridSize;y++){heightPoss[y]=[];objPoss[y]=[];for(let x=0;x<gridSize;x++){heightPoss[y][x]=[0,1,2,3,4];objPoss[y][x]=[0,1,2,3,4,5,6]}}collapse(heightPoss,heightTileCount,t=>allowed(t,heightTileCount));collapse(objPoss,tileCount,t=>allowed(t,tileCount));for(let y=0;y<gridSize;y++){heightMap[y]=[];objMap[y]=[];for(let x=0;x<gridSize;x++){heightMap[y][x]=heightPoss[y][x][0];objMap[y][x]=objPoss[y][x][0]}}for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const hIdx=heightMap[y][x],mesh=heightTiles[hIdx].clone();mesh.position.set((x-gridSize/2)*tileSize,0,(y-gridSize/2)*tileSize);mesh.rotation.x=-Math.PI/2;scene.add(mesh);const objIdx=objMap[y][x];if(objIdx>0){let obj;switch(objIdx%4){case 1:obj=new THREE.SphereGeometry(.45*tileSize);break;case 2:obj=new THREE.ConeGeometry(.4*tileSize,.9*tileSize,6);break;case 3:obj=new THREE.BoxGeometry(.7*tileSize,.7*tileSize,.7*tileSize);break;default:obj=null;}if(obj){const objM=new THREE.MeshStandardMaterial({color:tileColors[objIdx]});const o=new THREE.Mesh(obj,objM);o.position.set((x-gridSize/2)*tileSize,.12*tileSize,(y-gridSize/2)*tileSize);scene.add(o)}}}const heights=heightMap.map(r=>r.map(v=>1.1*v+0.05*Math.sin(v*2+5)));let user={x:gridSize/2,z:gridSize/2,y:0,rot:0,headYaw:0};function getHeightAt(x,z){x=Math.max(0,Math.min(gridSize-1,Math.floor(x)));z=Math.max(0,Math.min(gridSize-1,Math.floor(z)));return heights[z][x]}function updateCamera(){let y=getHeightAt(user.x,user.z)+PLAYER_HEIGHT;camera.position.set((user.x-gridSize/2)*tileSize,y,(user.z-gridSize/2)*tileSize);const yaw=user.rot+user.headYaw;camera.rotation.set(0,yaw,0);}const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(0,1,1);scene.add(light);let prevGamepadsLen=0,inputAxes=[0,0,0,0],snapCooldown=0;function handleGamepads(){const gps=navigator.getGamepads();if(!gps)return;let gp=null;for(let i=0;i<gps.length;i++)if(gps[i]&&gps[i].connected){gp=gps[i];break}if(!gp)return;if(gp.axes){inputAxes=gp.axes.slice(0,4)}if(gp.buttons[2]?.pressed||gp.buttons[0]?.pressed){if(snapCooldown<=0){user.headYaw+=(Math.PI/8)*(inputAxes[2]>0?.5:-.5);snapCooldown=15}}else snapCooldown=0;if(Math.abs(inputAxes[3])>.13||Math.abs(inputAxes[2])>.13){const speed=0.09,dir=user.rot+user.headYaw;user.x+=Math.sin(dir)*-inputAxes[3]*speed;user.z+=Math.cos(dir)*-inputAxes[3]*speed;user.x+=Math.sin(dir+Math.PI/2)*-inputAxes[2]*speed;user.z+=Math.cos(dir+Math.PI/2)*-inputAxes[2]*speed;user.x=Math.max(1,Math.min(gridSize-2,user.x));user.z=Math.max(1,Math.min(gridSize-2,user.z));}}renderer.setAnimationLoop(()=>{handleGamepads();updateCamera();renderer.render(scene,camera);if(snapCooldown>0)snapCooldown--});window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});updateCamera();</script></body></html>
