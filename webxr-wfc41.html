
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);scene.add(camera);let playerHeight=1.5,moveSpeed=0.08,rotSnap=Math.PI/7;let playerPos=new THREE.Vector3(0,playerHeight,0),playerRotY=0;const gridSize=18,mapSize=gridSize,tileSize=1.5;let tileCount=7,heightCount=7,heightColors=[0x183684,0x3f7c15,0x237247,0xbb8a2b,0xcf6826,0xb92d41,0xffffff];let objCount=5,objColors=[0x000000,0x46afe7,0xf4c542,0x992bdd,0xec2a63];let objGeoms=[null,new THREE.BoxGeometry(0.6,0.6,0.6),new THREE.ConeGeometry(0.34,0.6,8),new THREE.SphereGeometry(0.34,14,8),new THREE.TorusGeometry(0.3,0.10,8,14)];function randomArray(n){let a=[];for(let i=0;i<n;i++)a.push(i);return a}function allowedWFC(t,cnt){return[t,(t+1)%cnt,(t+cnt-1)%cnt]}function neighbors(x,y,s){return[[x-1,y],[x+1,y],[x,y-1],[x,y+1]].filter(([a,b])=>a>=0&&a<s&&b>=0&&b<s)}function collapseWFC(size,count,allowedFn){let out=[],poss=[];for(let y=0;y<size;y++){out[y]=[];poss[y]=[];for(let x=0;x<size;x++)poss[y][x]=randomArray(count)}let guard=0,unresolved=!0;for(;unresolved&&guard<size*size*10;){guard++;let min=count+1,choices=[];for(let y=0;y<size;y++)for(let x=0;x<size;x++){let l=poss[y][x].length; l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min===count+1){unresolved=!1;break}let[cx,cy]=choices[(Math.random()*choices.length)|0],options=poss[cy][cx];let pick=options[(Math.random()*options.length)|0];poss[cy][cx]=[pick];let q=[[cx,cy]];while(q.length){let[qx,qy]=q.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy,size)){let po=poss[ny][nx];if(po.length>1){let allow=allowedFn(tile);let filtered=po.filter(v=>allow.includes(v));if(filtered.length===0)filtered=[Math.random()*count|0];if(filtered.length!==po.length){poss[ny][nx]=filtered;q.push([nx,ny])}}}}}for(let y=0;y<size;y++)for(let x=0;x<size;x++)out[y][x]=poss[y][x][0];return out}let heightMap=collapseWFC(mapSize,heightCount,t=>allowedWFC(t,heightCount)),objectMap=collapseWFC(mapSize,objCount,t=>allowedWFC(t,objCount));let groundGeo=new THREE.PlaneGeometry(mapSize*tileSize,mapSize*tileSize,mapSize-1,mapSize-1);for(let i=0;i<groundGeo.attributes.position.count;i++){let vx=groundGeo.attributes.position.getX(i)/(tileSize)-mapSize/2,vy=groundGeo.attributes.position.getY(i),vz=groundGeo.attributes.position.getY(i)/(tileSize);let x=(groundGeo.attributes.position.getX(i)/tileSize+.5)|0;let y=(groundGeo.attributes.position.getY(i)/tileSize+.5)|0;let gx=(groundGeo.attributes.position.getX(i)/tileSize+mapSize/2)|0,gy=(groundGeo.attributes.position.getY(i)/tileSize+mapSize/2)|0;if(gx<0)gx=0;if(gx>=mapSize)gx=mapSize-1;if(gy<0)gy=0;if(gy>=mapSize)gy=mapSize-1;let h=heightMap[gy][gx]/2;groundGeo.attributes.position.setZ(i,h)}let colorArr=[];for(let i=0;i<groundGeo.attributes.position.count;i++){let gx=(groundGeo.attributes.position.getX(i)/tileSize+mapSize/2)|0,gy=(groundGeo.attributes.position.getY(i)/tileSize+mapSize/2)|0;if(gx<0)gx=0;if(gx>=mapSize)gx=mapSize-1;if(gy<0)gy=0;if(gy>=mapSize)gy=mapSize-1;let hc=heightColors[heightMap[gy][gx]];colorArr.push((hc>>16)/255,(hc>>8&255)/255,(hc&255)/255)}groundGeo.setAttribute('color',new THREE.Float32BufferAttribute(colorArr,3));let groundMat=new THREE.MeshStandardMaterial({vertexColors:true,flatShading:true});let ground=new THREE.Mesh(groundGeo,groundMat);ground.rotation.x=-Math.PI/2;ground.position.set(0,0,0);scene.add(ground);function getTileHeight(x,z){x=Math.floor(x/tileSize+mapSize/2),z=Math.floor(z/tileSize+mapSize/2);x=Math.max(0,Math.min(mapSize-1,x));z=Math.max(0,Math.min(mapSize-1,z));return heightMap[z][x]/2}for(let y=0;y<mapSize;y++)for(let x=0;x<mapSize;x++){let ob=objectMap[y][x];if(ob===0)continue;let m=new THREE.Mesh(objGeoms[ob],new THREE.MeshStandardMaterial({color:objColors[ob]}));let gx=(x-mapSize/2+.5)*tileSize,gz=(y-mapSize/2+.5)*tileSize;let gy=heightMap[y][x]/2+0.35; m.position.set(gx,gy,gz);scene.add(m)}const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(40,60,0);scene.add(light);let xrControls={};function handleGamepads(){let session=renderer.xr.getSession();if(!session)return;let pads=session.inputSources;for(let i=0;i<pads.length;i++){let p=pads[i];if(!p.gamepad)continue;if(p.handedness==="right"){xrControls.right=p.gamepad}else if(p.handedness==="left"){xrControls.left=p.gamepad}}}function vecFromAxes(gp){return gp?new THREE.Vector2(gp.axes[2]||0,gp.axes[3]||0):new THREE.Vector2(0,0)}let snapTimer=0;renderer.setAnimationLoop(function(){handleGamepads();let moveVec=new THREE.Vector2();if(xrControls.right){moveVec=vecFromAxes(xrControls.right);if(moveVec.lengthSq()>0.04){let forward=moveVec.y,side=moveVec.x;let rot=playerRotY;playerPos.x-=Math.sin(rot)*forward*moveSpeed+Math.cos(rot)*side*moveSpeed;playerPos.z-=Math.cos(rot)*forward*moveSpeed-Math.sin(rot)*side*moveSpeed;}}if(xrControls.left){let rotGp=xrControls.left;let axes=rotGp.axes;let lx=(axes[2]||0);if(Math.abs(lx)>0.68&&snapTimer<=0){playerRotY-=Math.sign(lx)*rotSnap;snapTimer=18}else if(Math.abs(lx)<0.2){snapTimer=0}else if(snapTimer>0){snapTimer--}}let underH=getTileHeight(playerPos.x,playerPos.z);playerPos.y=underH+playerHeight;camera.position.copy(playerPos);camera.rotation.set(0,playerRotY,0,"YXZ");renderer.render(scene,camera)});window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});</script></body></html>
