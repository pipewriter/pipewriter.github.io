
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';import {VRButton} from 'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:1});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=1;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const head=new THREE.Group();head.add(camera);scene.add(head);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);const gridSize=20,tileSize=1.5,tileCount=7,heightCount=5,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[],minHeight=0,maxHeight=8;for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}const heightColors=[0x5e7c16,0x8fb23b,0xdec97e,0xd6e4f0,0xffffff];const heights=[],objs=[],objTypes=['none','cube','sphere','cylinder','cone','torus'];function pickHeightTile(){return Math.floor(Math.random()*heightCount)}function allowed(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function allowedHeight(h){return[h,Math.max(0,h-1),Math.min(heightCount-1,h+1)]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapseLayer(layer,allowedRule,count){let unresolved=1,guard=0;while(unresolved&&guard<gridSize*gridSize*10){guard++;let min=count+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let len=layer[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min===count+1){unresolved=0;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=layer[cy][cx],pick=options[Math.random()*options.length|0];layer[cy][cx]=[pick];const queue=[[cx,cy]];while(queue.length){const[qx,qy]=queue.shift(),tile=layer[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=layer[ny][nx];if(poss.length>1){let allowedSet=allowedRule(tile);let next=poss.filter(v=>allowedSet.includes(v));if(next.length===0)next=[Math.floor(Math.random()*count)];if(next.length!==layer[ny][nx].length){layer[ny][nx]=next,queue.push([nx,ny])}}}}}}function buildMap(){for(let y=0;y<gridSize;y++){heights[y]=[];objs[y]=[];for(let x=0;x<gridSize;x++){heights[y][x]=[0,1,2,3,4];objs[y][x]=[0,1,2,3,4,5,6]}}collapseLayer(heights,allowedHeight,heightCount);collapseLayer(objs,allowed,tileCount)}buildMap();let meshMap=[],objMeshMap=[];function makePrim(type,color,scale,yoff){let mesh;let mat=new THREE.MeshStandardMaterial({color:color});if(type==='cube')mesh=new THREE.Mesh(new THREE.BoxGeometry(0.7*scale,0.7*scale,0.7*scale),mat);else if(type==='sphere')mesh=new THREE.Mesh(new THREE.SphereGeometry(0.4*scale,16,16),mat);else if(type==='cylinder')mesh=new THREE.Mesh(new THREE.CylinderGeometry(0.3*scale,0.3*scale,0.7*scale,16),mat);else if(type==='cone')mesh=new THREE.Mesh(new THREE.ConeGeometry(0.35*scale,0.7*scale,16),mat);else if(type==='torus')mesh=new THREE.Mesh(new THREE.TorusGeometry(0.25*scale,0.13*scale,12,24),mat);if(mesh)mesh.position.y+=yoff;return mesh}for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let h=heights[y][x][0],col=heightColors[h%heightColors.length],mesh=new THREE.Mesh(new THREE.BoxGeometry(tileSize,maxHeight/heightCount*(h+1),tileSize),new THREE.MeshStandardMaterial({color:col,vertexColors:0}));mesh.position.set((x-gridSize/2)*tileSize,maxHeight/heightCount*(h+1)/2,(y-gridSize/2)*tileSize);scene.add(mesh);meshMap.push(mesh);let objTypeIndex=objs[y][x][0],objType=objTypes[objTypeIndex%objTypes.length];if(objType!=='none'){let om=makePrim(objType,colors[objTypeIndex%colors.length],1,maxHeight/heightCount*(h+1)+0.42);if(om){om.position.x=mesh.position.x;om.position.z=mesh.position.z;scene.add(om);objMeshMap.push(om)}}}let rig=new THREE.Group();scene.add(rig);rig.add(head);const fixedPlayerHeight=1.2;let velocity=new THREE.Vector3(),rotDelta=0,joystickState={leftX:0,leftY:0,rightX:0,rightY:0};function aggregateGamepads(){let pads=navigator.getGamepads?navigator.getGamepads():[];let j={leftX:0,leftY:0,rightX:0,rightY:0};for(let p of pads){if(p&&p.axes.length>=4){j.leftX+=p.axes[2];j.leftY+=p.axes[3];j.rightX+=p.axes[0];j.rightY+=p.axes[1];}}return j}let canSnap=1;renderer.setAnimationLoop(()=>{joystickState=aggregateGamepads();let moveSpeed=.04,rotAngle=Math.PI/8;if(Math.abs(joystickState.rightY)>0.17||Math.abs(joystickState.rightX)>0.17){let dir=new THREE.Vector3();head.getWorldDirection(dir);dir.y=0;dir.normalize();let right=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();let dx=joystickState.rightX,dy=joystickState.rightY;let delta=new THREE.Vector3().addScaledVector(dir,-dy*moveSpeed).addScaledVector(right,dx*moveSpeed);rig.position.add(delta);}if(canSnap&&(Math.abs(joystickState.leftX)>0.6)){let sign=joystickState.leftX>0?1:-1;rig.rotation.y-=sign*rotAngle;canSnap=0;}if(Math.abs(joystickState.leftX)<0.3)canSnap=1;let rigx=(rig.position.x+gridSize*tileSize/2)/tileSize,rigz=(rig.position.z+gridSize*tileSize/2)/tileSize,xx=Math.floor(rigx),zz=Math.floor(rigz);xx=Math.max(0,Math.min(gridSize-1,xx));zz=Math.max(0,Math.min(gridSize-1,zz));let currentH=heights[zz]&&heights[zz][xx]?heights[zz][xx][0]:0;let groundY=maxHeight/heightCount*(currentH+1);head.position.set(0,groundY+fixedPlayerHeight,0);renderer.render(scene,camera)});</script></body></html>
