
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';import { VRButton } from 'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);let player={y:0,x:0,z:0,heading:0,height:1.7};camera.position.set(0,player.height,0);let light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);let gridSize=20,tileSize=1.5,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){let g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}let heightPoss=[],heightVals=[],minH=-1.5,maxH=4,objectPoss=[],objectTiles=[null,"box","sphere","cylinder"],objectColors=[0xaaaaaa,0xff4444,0x44ff44,0x4444ff];for(let y=0;y<gridSize;y++){heightPoss[y]=[],heightVals[y]=[],objectPoss[y]=[];for(let x=0;x<gridSize;x++){heightPoss[y][x]=[0,1,2,3,4,5,6];objectPoss[y][x]=[0,1,2,3]}}function allowedH(t){return [t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function allowedO(t){return [t,0]}function nbs(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapsePoss(poss,allowed){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=999,cho=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let l=poss[y][x].length;l>1&&l<min?(min=l,cho=[[x,y]]):l===min&&cho.push([x,y])}if(min>gridSize){unresolved=!1;break}let[cx,cy]=cho[Math.random()*cho.length|0],opts=poss[cy][cx],pick=opts[Math.random()*opts.length|0];poss[cy][cx]=[pick];let queue=[[cx,cy]];for(;queue.length;){let[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(let[nx,ny]of nbs(qx,qy)){let p=poss[ny][nx];if(p.length>1){let ok=allowed(tile);if(p=p.filter(v=>ok.includes(v)),0===p.length&&(p=[0]),p.length!==poss[ny][nx].length){poss[ny][nx]=p,queue.push([nx,ny])}}}}}}collapsePoss(heightPoss,allowedH);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let t=heightPoss[y][x][0],h=minH+(maxH-minH)*t/(tileCount-1);heightVals[y][x]=h}collapsePoss(objectPoss,allowedO);let ground=new THREE.Group(),objGroup=new THREE.Group();scene.add(ground);scene.add(objGroup);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let t=heightPoss[y][x][0],mesh=tiles[t].clone();let h=heightVals[y][x];for(let v of mesh.geometry.attributes.position.array.entries()){if(v[0]%3===1)mesh.geometry.attributes.position.array[v[0]]=h}mesh.geometry.attributes.position.needsUpdate=!0;let c=colorLerp(colors[0],colors[6],(h-minH)/(maxH-minH)),vColor=new THREE.Color(c);let colorsArr=[];for(let i=0;i<mesh.geometry.attributes.position.count;i++)colorsArr.push(vColor.r,vColor.g,vColor.b);mesh.geometry.setAttribute('color',new THREE.Float32BufferAttribute(colorsArr,3));mesh.material=new THREE.MeshStandardMaterial({vertexColors:!0});mesh.position.set((x-gridSize/2)*tileSize,0,(y-gridSize/2)*tileSize);ground.add(mesh);let o=objectPoss[y][x][0];if(o!==0){let prim;let oy=h+.2;let sc=.5*tileSize;if(objectTiles[o]==="box")prim=new THREE.Mesh(new THREE.BoxGeometry(sc,sc,sc),new THREE.MeshStandardMaterial({color:objectColors[o]}));else if(objectTiles[o]==="sphere")prim=new THREE.Mesh(new THREE.SphereGeometry(sc/2,12,12),new THREE.MeshStandardMaterial({color:objectColors[o]}));else if(objectTiles[o]==="cylinder")prim=new THREE.Mesh(new THREE.CylinderGeometry(sc/2,sc/2,sc,.75,12),new THREE.MeshStandardMaterial({color:objectColors[o]}));prim&&((prim.position.set((x-gridSize/2)*tileSize,oy,(y-gridSize/2)*tileSize)),objGroup.add(prim))}}function colorLerp(c1,c2,t){let a1=new THREE.Color(c1),a2=new THREE.Color(c2);return a1.lerp(a2,t).getHex()}renderer.xr.addEventListener('sessionstart',()=>{player.x=0;player.z=0;player.heading=0;});function getGroundHeight(x,z){let fx=x/tileSize+gridSize/2,fz=z/tileSize+gridSize/2;let xi=Math.floor(fx),zi=Math.floor(fz),xi1=Math.min(xi+1,gridSize-1),zi1=Math.min(zi+1,gridSize-1);let tx=fx-xi,tz=fz-zi;if(xi<0||zi<0||xi1>=gridSize||zi1>=gridSize)return 0;let h00=heightVals[zi][xi],h10=heightVals[zi][xi1],h01=heightVals[zi1][xi],h11=heightVals[zi1][xi1];let h0=h00*(1-tx)+h10*tx,h1=h01*(1-tx)+h11*tx;return h0*(1-tz)+h1*tz}let prevLeftY=0,errAccum=0,turning=0;let gamepadIdxL=null,gamepadIdxR=null;function handleVRControls(){let sess=renderer.xr.getSession(),input=sess?sess.inputSources:[];if(input.length<2)return;let l=input[0]?.gamepad,r=input[1]?.gamepad;if(!l||!r)return;let [lx,ly]=[l.axes[2]||l.axes[0],l.axes[3]||l.axes[1]],[rx,ry]=[r.axes[2]||r.axes[0],r.axes[3]||r.axes[1]];let spd=0.07;player.x+=Math.sin(player.heading)*ry*spd+Math.cos(player.heading)*rx*spd;player.z+=Math.cos(player.heading)*ry*spd-Math.sin(player.heading)*rx*spd;let rotSpeed=Math.PI/6;if(Math.abs(lx)>0.6&&turning==0){player.heading+=lx>0?rotSpeed:-rotSpeed;turning=10}else if(Math.abs(lx)<.15)turning=0;if(turning)turning-=1}renderer.setAnimationLoop(()=>{handleVRControls();let y=getGroundHeight(player.x,player.z)+player.height;camera.position.set(player.x,y,player.z);let eul=new THREE.Euler(0,player.heading,0,"YXZ");camera.quaternion.setFromEuler(eul);renderer.render(scene,camera)});window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});</script></body></html>
```
