
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let scene=new THREE.Scene,renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight),renderer.xr.enabled=!0,document.body.appendChild(renderer.domElement),document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.01,1e3);camera.position.set(0,6,10);camera.lookAt(0,0,0);scene.add(new THREE.DirectionalLight(16777215,1));const gridSize=16,tileSize=2,heightTiles=6,surfaceColors=[0x6b9d43,0xabcca9,0xEFEAC5,0xB38B47,0x5683A7,0xAF2323],heightLevels=[-1.5,0,1,2,3,4],objectProbs=[.7,.08,.08,.07,.07],objectTypes=['none','cube','sphere','cone','cylinder'],objectColors=[0,0x3366ff,0xff6666,0x0eeeee,0xf5f502],tiles=[];for(let h=0;h<heightTiles;h++){let g=new THREE.BoxGeometry(tileSize,.2*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:surfaceColors[h]});tiles.push(new THREE.Mesh(g,m))}function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.random()*(i+1)|0,[x,y]=[a[i],a[j]];a[i]=y,a[j]=x}}function allowed(h){return[h,(h+1)%heightTiles,(h+heightTiles-1)%heightTiles]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}let hposs=[],oposs=[];for(let y=0;y<gridSize;y++){hposs[y]=[],oposs[y]=[];for(let x=0;x<gridSize;x++)hposs[y][x]=Array.from({length:heightTiles},(_,i)=>i),oposs[y][x]=[0,1,2,3,4]}function collapse2d(poss,allowedfn,len){let unresolved=!0,guard=0;while(unresolved&&guard<gridSize*gridSize*10){guard++;let min=len+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let l=poss[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min>len){unresolved=!1;break}let[cx,cy]=choices[Math.random()*choices.length|0],opt=poss[cy][cx],pick=opt[Math.random()*opt.length|0];poss[cy][cx]=[pick];let queue=[[cx,cy]];while(queue.length){let[qx,qy]=queue.shift(),idx=poss[qy][qx][0];for(let[nx,ny]of neighbors(qx,qy)){let p=poss[ny][nx];if(p.length>1){let allowedset=allowedfn(idx);if(p=p.filter(v=>allowedset.includes(v)),0===p.length&&(p=[Math.random()*len|0]),p.length!==poss[ny][nx].length)poss[ny][nx]=p,queue.push([nx,ny])}}}}}collapse2d(hposs,allowed,heightTiles);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let hidx=hposs[y][x][0];if(Math.random()<.92){oposs[y][x]=[0];continue}let picks=[],sum=objectProbs.reduce((a,b)=>a+b);let r=Math.random()*sum;for(let i=0,c=0;i<objectProbs.length;i++)if(r<=(c+=objectProbs[i])){picks=[i];break}oposs[y][x]=picks.length?picks:[0]}function getColorByHeight(idx){return surfaceColors[idx%surfaceColors.length]}collapse2d(oposs,t=>([0,1,2,3,4]),5);let offset=tileSize*(gridSize/2),htmap=[];for(let y=0;y<gridSize;y++)htmap[y]=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let hidx=hposs[y][x][0],hx=heightLevels[hidx%heightLevels.length],mesh=tiles[hidx].clone();mesh.position.set((x-gridSize/2)*tileSize,hx,(y-gridSize/2)*tileSize);mesh.material=new THREE.MeshStandardMaterial({color:surfaceColors[hidx%surfaceColors.length],vertexColors:!0});let geometry=mesh.geometry.toNonIndexed();let color=new THREE.Color(surfaceColors[hidx%surfaceColors.length]);let cattr=[];for(let i=0;i<geometry.attributes.position.count;i++)cattr.push(color.r,color.g*.9+.1*Math.random(),color.b);geometry.setAttribute('color',new THREE.Float32BufferAttribute(cattr,3)),mesh.geometry=geometry,scene.add(mesh),htmap[y][x]=hx;let oidx=oposs[y][x][0];if(oidx){let objMesh,clr=objectColors[oidx%objectColors.length],os=tileSize*.5;switch(objectTypes[oidx]){case"cube":objMesh=new THREE.Mesh(new THREE.BoxGeometry(.9*os,.9*os,.9*os),new THREE.MeshStandardMaterial({color:clr}));break;case"sphere":objMesh=new THREE.Mesh(new THREE.SphereGeometry(.5*os,16,16),new THREE.MeshStandardMaterial({color:clr}));break;case"cone":objMesh=new THREE.Mesh(new THREE.ConeGeometry(.5*os,os,16),new THREE.MeshStandardMaterial({color:clr})),objMesh.position.y+=.3*os;break;case"cylinder":objMesh=new THREE.Mesh(new THREE.CylinderGeometry(.5*os,.5*os,.9*os,16),new THREE.MeshStandardMaterial({color:clr}));break;}if(objMesh)objMesh.position.set((x-gridSize/2)*tileSize,hx+.71*(tileSize*.1)+os*.5,(y-gridSize/2)*tileSize),scene.add(objMesh)}}let cameraOffsetY=1.6,player={x:gridSize/2,z:gridSize/2,dir:0,speed:0.13,rotStep:THREE.MathUtils.degToRad(30)};function updatePlayerHeight(){let gx=Math.round(player.x),gz=Math.round(player.z);gx=Math.max(0,Math.min(gridSize-1,gx)),gz=Math.max(0,Math.min(gridSize-1,gz));let h=htmap[gz][gx];camera.position.set(player.x*tileSize-gridSize/2*tileSize,h+cameraOffsetY,player.z*tileSize-gridSize/2*tileSize)}function clampPlayer(){player.x=Math.max(.5,Math.min(gridSize-.5,player.x)),player.z=Math.max(.5,Math.min(gridSize-.5,player.z))}let pressedLeft=0;function handleVRControls(){if(renderer.xr.isPresenting){let s=renderer.xr.getSession(),input=s.inputSources;input.forEach(src=>{if(!src.gamepad)return;let[G0,G1,G2,G3]=src.gamepad.axes,lstickH=G2,lstickV=G3,rstickH=G0,rstickV=G1;if(src.handedness==='left'){if(Math.abs(lstickH)>.6&&!pressedLeft){player.dir+=player.rotStep*(lstickH>0?-1:1),pressedLeft=1}else if(Math.abs(lstickH)<=.3)pressedLeft=0}else{let dx=-Math.sin(player.dir)*rstickV+Math.cos(player.dir)*rstickH,dz=-Math.cos(player.dir)*rstickV-Math.sin(player.dir)*rstickH;player.x+=player.speed*dx,player.z+=player.speed*dz,clampPlayer()}})}updatePlayerHeight()}renderer.setAnimationLoop(()=>{handleVRControls(),renderer.render(scene,camera)});window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight),camera.aspect=window.innerWidth/window.innerHeight,camera.updateProjectionMatrix()});</script></body></html>
