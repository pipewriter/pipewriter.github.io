
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene,renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight),renderer.xr.enabled=!0,document.body.appendChild(renderer.domElement),document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const PLAYER_HEIGHT=1.7;let camRig=new THREE.Group;camRig.add(camera),scene.add(camRig),camera.position.set(0,PLAYER_HEIGHT,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);const gridSize=16,tileSize=2,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}const heightLevels=5,heightColors=[0x7EC850,0x47A33C,0xCD853F,0x808080,0x6A5ACD],heightTiles=[];for(let i=0;i<heightLevels;i++){let geom=new THREE.BoxGeometry(tileSize,(.25+i*.1)*tileSize,tileSize),mat=new THREE.MeshStandardMaterial({color:heightColors[i],vertexColors:!0});heightTiles.push(new THREE.Mesh(geom,mat))}function allowed(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function allowedH(h){return[h,Math.max(0,h-1),Math.min(heightLevels-1,h+1)]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function wfcSolve(possibilities,allowF,levels){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=levels+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=possibilities[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min===levels+1){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=possibilities[cy][cx],pick=options[Math.random()*options.length|0];possibilities[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),v=possibilities[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=possibilities[ny][nx];if(poss.length>1){const allowedSet=allowF(v);if(poss=poss.filter(t=>allowedSet.includes(t)),0===poss.length&&(poss=[Math.random()*levels|0]),poss.length!==possibilities[ny][nx].length){possibilities[ny][nx]=poss,queue.push([nx,ny])}}}}}}let hposs=[],tposs=[];for(let y=0;y<gridSize;y++){hposs[y]=[],tposs[y]=[];for(let x=0;x<gridSize;x++)hposs[y][x]=[0,1,2,3,4],tposs[y][x]=[0,1,2,3,4,5,6]}wfcSolve(hposs,allowedH,heightLevels),wfcSolve(tposs,allowed,tileCount);function getHeight(y,x){return hposs[y][x][0]}function getTile(y,x){return tposs[y][x][0]}function getHeightColor(i){return heightColors[i]}let mapMeshes=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let h=getHeight(y,x),t=getTile(y,x),mt=heightTiles[h].clone();mt.position.set((x-gridSize/2)*tileSize,.5*((.25+h*.1)*tileSize)-.01,(y-gridSize/2)*tileSize),mt.material=mt.material.clone(),mt.material.color=new THREE.Color(getHeightColor(h)),scene.add(mt),mapMeshes.push(mt);if(t!==0){let p,mc;switch(t){case 1:p=new THREE.SphereGeometry(tileSize*.35,18,14),mc=0xeeeeee;break;case 2:p=new THREE.ConeGeometry(tileSize*.27,tileSize*.45,6),mc=0xff9800;break;case 3:p=new THREE.CylinderGeometry(tileSize*.12,tileSize*.12,tileSize*.35,14),mc=0x483D8B;break;case 4:p=new THREE.TorusGeometry(tileSize*.22,tileSize*.08,12,24),mc=0x00CED1;break;case 5:p=new THREE.OctahedronGeometry(tileSize*.22),mc=0xFF69B4;break;case 6:p=new THREE.DodecahedronGeometry(tileSize*.18),mc=0xFFD700;break;}if(p){let omesh=new THREE.Mesh(p,new THREE.MeshStandardMaterial({color:mc}));omesh.position.set((x-gridSize/2)*tileSize,.5*((.25+h*.1)*tileSize)+tileSize*.2,(y-gridSize/2)*tileSize),scene.add(omesh),mapMeshes.push(omesh)}}}let leftAxisX=0,rightAxisY=0,rightAxisX=0,vrControlsReady=!1;renderer.xr.addEventListener('sessionstart',()=>{vrControlsReady=!0});renderer.xr.addEventListener('sessionend',()=>{vrControlsReady=!1});function handleGamepads(){const pads=navigator.getGamepads?navigator.getGamepads():[];for(let i=0;i<pads.length;i++){const p=pads[i];if(!p||!p.axes||!p.buttons)continue;let lx=p.axes[2]||0,ly=p.axes[3]||0,rx=p.axes[0]||0,ry=p.axes[1]||0;leftAxisX=lx,rightAxisX=rx,rightAxisY=ry;}}let yaw=0,snapCooldown=0;function getFloorY(x,z){let xi=Math.floor((x/tileSize)+gridSize/2),zi=Math.floor((z/tileSize)+gridSize/2);xi=Math.max(0,Math.min(gridSize-1,xi)),zi=Math.max(0,Math.min(gridSize-1,zi));let h=hposs[zi][xi][0];return .5*((.25+h*.1)*tileSize)}renderer.setAnimationLoop(()=>{if(vrControlsReady){handleGamepads();let moveSpeed=.07;let dx=Math.sin(yaw)*rightAxisY+Math.cos(yaw)*rightAxisX,dz=Math.cos(yaw)*rightAxisY-Math.sin(yaw)*rightAxisX,newX=camRig.position.x+dx*moveSpeed,newZ=camRig.position.z+dz*moveSpeed,floorY=getFloorY(newX,newZ);camRig.position.x=newX;camRig.position.z=newZ;camRig.position.y=floorY+PLAYER_HEIGHT;if(leftAxisX&&Math.abs(leftAxisX)>.75&&snapCooldown<=0){snapCooldown=25;const snapAngle=Math.PI/6*yawSign(leftAxisX);yaw+=snapAngle,camRig.rotation.y=yaw;}else snapCooldown>0&&(snapCooldown--)}renderer.render(scene,camera)});function yawSign(x){return x>0?1:-1}window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight,camera.updateProjectionMatrix(),renderer.setSize(window.innerWidth,window.innerHeight)});</script></body></html>
```
