
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);scene.add(camera);const head=new THREE.Object3D();camera.add(head);head.position.set(0,0,0);let playerY=0,playerX=0,playerZ=0,playerRot=0;const PLAYER_HEIGHT=2;const gridSize=16;const tileSize=2;const tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){let g=new THREE.BoxGeometry(tileSize,.3,tileSize);let m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}const heightPoss=[],objectPoss=[],maxH=3,minH=-1;for(let y=0;y<gridSize;y++){heightPoss[y]=[];objectPoss[y]=[];for(let x=0;x<gridSize;x++){heightPoss[y][x]=[0,1,2,3];objectPoss[y][x]=[0,1,2,3,4]}}function allowedHeight(t){return[t,Math.max(minH,Math.min(maxH,t+1)),Math.max(minH,Math.min(maxH,t-1))]}function allowedObj(t){return[0,1,2,3,4]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapseField(field,allowedFn,choices){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=99,l=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=field[y][x].length;len>1&&len<min?(min=len,l=[[x,y]]):len===min&&l.push([x,y])}if(min===99){unresolved=!1;break}const[cx,cy]=l[Math.random()*l.length|0],options=field[cy][cx],pick=options[Math.random()*options.length|0];field[cy][cx]=[pick];const q=[[cx,cy]];for(;q.length;){const[qx,qy]=q.shift(),tile=field[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=field[ny][nx];if(poss.length>1){const allowedSet=allowedFn(tile);if(poss=poss.filter(v=>allowedSet.includes(v)),poss.length===0&&(poss=[choices[Math.random()*choices.length|0]]),poss.length!==field[ny][nx].length){field[ny][nx]=poss,q.push([nx,ny])}}}}}}collapseField(heightPoss,(h)=>{let res=[h];if(h<maxH)res.push(h+1);if(h>minH)res.push(h-1);return res;},[0,1,2,3]);collapseField(objectPoss,allowedObj,[0,1,2,3,4]);const mapObjs=[],objTypes=[null,"sphere","box","cylinder","cone"];const objColors=[null,0xff9999,0x99ff99,0x9999ff,0xaaaaff];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const hIdx=heightPoss[y][x][0],tileIdx=(hIdx+tileCount)%tileCount,mesh=tiles[tileIdx].clone();const hgt=minH+hIdx;mesh.position.set((x-gridSize/2)*tileSize,hgt*1.1,(y-gridSize/2)*tileSize);mesh.material=new THREE.MeshStandardMaterial({color:colors[tileIdx]});mesh.geometry=new THREE.BoxGeometry(tileSize,1.2,tileSize);const vColorMesh=mesh.clone();let c=colors[tileIdx],cV=new THREE.Color(c);const geo=mesh.geometry;const attr=geo.attributes.position,count=attr.count,colorArr=[];for(let i=0;i<count;i++){colorArr.push(cV.r,cV.g,cV.b);}geo.setAttribute("color",new THREE.Float32BufferAttribute(colorArr,3));mesh.material.vertexColors=!0;scene.add(mesh);const objIdx=objectPoss[y][x][0];if(objIdx!==0){let objMesh;let px=(x-gridSize/2)*tileSize,py=hgt*1.1+0.8,pz=(y-gridSize/2)*tileSize;if(objTypes[objIdx]==="sphere")objMesh=new THREE.Mesh(new THREE.SphereGeometry(0.5),new THREE.MeshStandardMaterial({color:objColors[objIdx]}));else if(objTypes[objIdx]==="box")objMesh=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({color:objColors[objIdx]}));else if(objTypes[objIdx]==="cylinder")objMesh=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1,12),new THREE.MeshStandardMaterial({color:objColors[objIdx]}));else if(objTypes[objIdx]==="cone")objMesh=new THREE.Mesh(new THREE.ConeGeometry(0.5,1,12),new THREE.MeshStandardMaterial({color:objColors[objIdx]}));if(objMesh){objMesh.position.set(px,py,pz);scene.add(objMesh);mapObjs.push(objMesh)}}}const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(0,10,10);scene.add(light);scene.add(new THREE.AmbientLight(0xffffff,.6));const sessionFuncs=[];renderer.xr.addEventListener("sessionstart",e=>{if(renderer.xr.getSession()){renderer.xr.getSession().addEventListener("inputsourceschange",handleControllers)}});let controllerL,controllerR;function handleControllers(){const inputSources=renderer.xr.getSession().inputSources;controllerL=null;controllerR=null;for(const s of inputSources)"gamepad"in s&&(s.handedness==="left"?controllerL=s:s.handedness==="right"&&(controllerR=s))}let snapRotCooldown=0;function processVRPadMove(){let moveX=0,moveZ=0,snapL=0;if(controllerL&&controllerL.gamepad){const gp=controllerL.gamepad;const[ax,ay]=gp.axes;Math.abs(ax)>0.5&&(snapL=ax);snapL<-0.5?snapL=-1:snapL>0.5?snapL=1:snapL=0}if(controllerR&&controllerR.gamepad){const gp=controllerR.gamepad;const[ax,ay]=gp.axes;Math.abs(ay)>0.02&&(moveZ+=ay);Math.abs(ax)>0.02&&(moveX+=ax)}if(snapRotCooldown<=0&&snapL){playerRot+=snapL*Math.PI/4;snapRotCooldown=20}else snapRotCooldown>0&&snapRotCooldown--;const speed=0.1;const sin=Math.sin(playerRot),cos=Math.cos(playerRot);playerX+=moveX*speed*cos-moveZ*speed*sin;playerZ+=moveX*speed*sin+moveZ*speed*cos;let gx=Math.round(playerX/tileSize+gridSize/2),gz=Math.round(playerZ/tileSize+gridSize/2);if(gx>=0&&gx<gridSize&&gz>=0&&gz<gridSize){const hIdx=heightPoss[gz][gx][0];let yt=(minH + hIdx)*1.1 + PLAYER_HEIGHT;playerY=yt}else playerY=PLAYER_HEIGHT;}renderer.setAnimationLoop(()=>{processVRPadMove();camera.position.set(playerX,playerY,playerZ);camera.rotation.y=playerRot;renderer.render(scene,camera)});window.addEventListener("resize",()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()})</script></body></html>
