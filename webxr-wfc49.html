
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';import {VRButton} from 'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const PLAYER_HEIGHT=1.7;let playerPos=new THREE.Vector3(0,PLAYER_HEIGHT,0),playerRot=0;camera.position.copy(playerPos);camera.lookAt(0,0,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,10,10).normalize();scene.add(light);const gridSize=14,tileSize=2,tileCount=8,heightLevels=4,heightStep=1.2,baseY=-1.6,map={tiles:[],height:[],objects:[]},tileColors=[16711680,65280,255,16776960,16711935,32768,16777215,8421504],objTypes=[null,'cube','sphere','cone'],objColors=[0x000000,0xffffff,0x3333ff,0x33ff33,0xff3333,0xff00ff];for(let y=0;y<gridSize;y++){map.tiles.push([]);map.height.push([]);map.objects.push([]);for(let x=0;x<gridSize;x++){map.tiles[y][x]=[0,1,2,3,4,5,6,7];map.height[y][x]=[0,1,2,3];map.objects[y][x]=[0,1,2,3];}}function allowedTile(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function allowedHeight(h){return[h,(h+1)%heightLevels,(h+heightLevels-1)%heightLevels]}function allowedObj(o){return[o,(o+1)%objTypes.length,(o+objTypes.length-1)%objTypes.length]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapseLayer(layer,allowedFn,count){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*12;){guard++;let min=count+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=layer[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min>count){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=layer[cy][cx],pick=options[Math.random()*options.length|0];layer[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),val=layer[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=layer[ny][nx];if(poss.length>1){const allowedSet=allowedFn(val);poss=poss.filter(v=>allowedSet.includes(v));if(0===poss.length)poss=[Math.random()*count|0];if(poss.length!==layer[ny][nx].length){layer[ny][nx]=poss,queue.push([nx,ny]);}}}}}}}collapseLayer(map.height,allowedHeight,heightLevels-1);collapseLayer(map.tiles,allowedTile,tileCount-1);collapseLayer(map.objects,allowedObj,objTypes.length-1);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const tileIdx=map.tiles[y][x][0],hIdx=map.height[y][x][0],objIdx=map.objects[y][x][0],height=baseY+hIdx*heightStep;const geo=new THREE.BoxGeometry(tileSize,heightStep*0.8,tileSize),mat=new THREE.MeshStandardMaterial({vertexColors:!0});const mesh=new THREE.Mesh(geo,mat);const color=new THREE.Color(tileColors[tileIdx]);let colors=[];for(let i=0;i<geo.attributes.position.count;i++)colors.push(color.r,color.g,color.b);geo.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));mesh.position.set((x-gridSize/2)*tileSize,height,(y-gridSize/2)*tileSize);scene.add(mesh);if(objIdx>0){let objG,ocol=objColors[objIdx%objColors.length];let oy=height+heightStep*0.53;switch(objIdx){case 1:objG=new THREE.BoxGeometry(0.7,0.7,0.7);break;case 2:objG=new THREE.SphereGeometry(0.38,14,12);break;case3:objG=new THREE.ConeGeometry(0.47,0.9,6);break;default:objG=new THREE.BoxGeometry(0.4,0.4,0.4);}const objM=new THREE.MeshStandardMaterial({color:ocol});const objMesh=new THREE.Mesh(objG,objM);objMesh.position.set((x-gridSize/2)*tileSize,oy,(y-gridSize/2)*tileSize);scene.add(objMesh);}}function clamp(v,a,b){return Math.max(a,Math.min(b,v));}let controllers=[],snapRot=THREE.MathUtils.degToRad(35),snapRotCooldown=0,snapDelay=9;renderer.xr.addEventListener("sessionstart",()=>{controllers=[renderer.xr.getController(0),renderer.xr.getController(1)];controllers.forEach(c=>scene.add(c));});let gamepadStates=[null,null],movementV=new THREE.Vector3(),snapSince=0;function pollGamepads(){if(!renderer.xr.isPresenting)return;for(let i=0;i<2;i++){const input=renderer.xr.getController(i);if(!input||!input.gamepad)continue;const gp=input.gamepad,axes=gp.axes,state={axes:axes.slice(),buttons:gp.buttons.map(b=>b.pressed)};gamepadStates[i]=state;}}function getGroundHeightAt(px,pz){let fx=px/tileSize+gridSize/2,fy=pz/tileSize+gridSize/2;let ix=Math.floor(fx),iz=Math.floor(fy);if(ix<0||ix>=gridSize||iz<0||iz>=gridSize)return baseY;return baseY+map.height[iz][ix][0]*heightStep;}renderer.setAnimationLoop(()=>{pollGamepads();let walkSpeed=0.057,turn=0;if(gamepadStates[1]){let ax=gamepadStates[1].axes[2]||0,ay=-(gamepadStates[1].axes[3]||0);let move=new THREE.Vector3(ax,0,ay);if(move.length()>0.1){move.normalize().multiplyScalar(walkSpeed);let angle=playerRot;let sin=Math.sin(angle),cos=Math.cos(angle);let mx=move.x*cos-move.z*sin,mz=move.x*sin+move.z*cos;movementV.set(mx,0,mz);playerPos.add(movementV);}}if(gamepadStates[0]&&snapRotCooldown<=0){let lx=gamepadStates[0].axes[2]||0;if(lx<-0.6){playerRot-=snapRot;snapRotCooldown=snapDelay;}else if(lx>0.6){playerRot+=snapRot;snapRotCooldown=snapDelay;}}if(snapRotCooldown>0)snapRotCooldown--;let groundY=getGroundHeightAt(playerPos.x,playerPos.z);playerPos.y=groundY+PLAYER_HEIGHT;camera.position.copy(playerPos);camera.rotation.set(0,playerRot,0);renderer.render(scene,camera);});window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();});</script></body></html>
