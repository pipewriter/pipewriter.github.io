
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR Large Map Dual Layer</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);scene.add(camera);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,20,0);scene.add(light);const gridSize=20,tileSize=2.5,heightMin=0,heightMax=8,heightTileCount=5,heightColors=[0x3e9626,0x7bb661,0xd9c46c,0x8c8c8c,0xffffff],overlayTileCount=5,overlayColors=[0,0xff0000,0x0000ff,0x00ffff,0xffff00],overlayShapes=["none","box","sphere","cylinder","cone"],heightTiles=[],overlayMeshes={};for(let i=0;i<heightTileCount;i++){const g=new THREE.BoxGeometry(tileSize,.35*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:heightColors[i]});heightTiles.push(new THREE.Mesh(g,m))}overlayMeshes["box"]=new THREE.Mesh(new THREE.BoxGeometry(tileSize*.35,tileSize*.6,tileSize*.35),new THREE.MeshStandardMaterial({color:overlayColors[1]}));overlayMeshes["sphere"]=new THREE.Mesh(new THREE.SphereGeometry(tileSize*.25,12,12),new THREE.MeshStandardMaterial({color:overlayColors[2]}));overlayMeshes["cylinder"]=new THREE.Mesh(new THREE.CylinderGeometry(tileSize*.17,tileSize*.17,tileSize*.5,10),new THREE.MeshStandardMaterial({color:overlayColors[3]}));overlayMeshes["cone"]=new THREE.Mesh(new THREE.ConeGeometry(tileSize*.21,tileSize*.5,10),new THREE.MeshStandardMaterial({color:overlayColors[4]}));function allowedTile(t){return[t,(t+1)%heightTileCount,(t+heightTileCount-1)%heightTileCount]}function allowedOverlay(t){return overlayShapes}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapseWFC(poss,allowedF,tileN){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*20;){guard++;let min=tileN+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(tileN+1===min){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let possn=poss[ny][nx];if(possn.length>1){const allowedSet=allowedF(tile);if(possn=possn.filter(v=>allowedSet.includes(v)),0===possn.length&&(possn=[Math.random()*tileN|0]),possn.length!==poss[ny][nx].length){poss[ny][nx]=possn,queue.push([nx,ny])}}}}}}const heightPoss=[],overlayPoss=[];for(let y=0;y<gridSize;y++){heightPoss[y]=[];overlayPoss[y]=[];for(let x=0;x<gridSize;x++){heightPoss[y][x]=[0,1,2,3,4];overlayPoss[y][x]=[...overlayShapes]}}collapseWFC(heightPoss,allowedTile,heightTileCount);collapseWFC(overlayPoss,allowedOverlay,overlayTileCount);const groundMeshes=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const tileI=heightPoss[y][x][0],baseY=heightMin+(heightMax-heightMin)/(heightTileCount-1)*tileI,mesh=heightTiles[tileI].clone();mesh.position.set((x-gridSize/2)*tileSize,baseY-tileSize/2,(y-gridSize/2)*tileSize);scene.add(mesh);groundMeshes.push(mesh);const overlay=overlayPoss[y][x][0];if("none"!==overlay){const prim=overlayMeshes[overlay].clone();prim.material=prim.material.clone();prim.material.color.setHex(overlayColors[overlayShapes.indexOf(overlay)]);prim.position.set((x-gridSize/2)*tileSize,baseY+tileSize*.25,(y-gridSize/2)*tileSize);scene.add(prim)}}let userY=0,userX=0;camera.position.set(0,8,0);let playerHeight=1.7,moveSpeed=0.08,rotSnap=Math.PI/8,snapPending=!1;function getGroundY(x,z){let gx=Math.floor(x/tileSize+gridSize/2),gz=Math.floor(z/tileSize+gridSize/2);if(gx<0||gx>=gridSize||gz<0||gz>=gridSize)return 0;const tileI=heightPoss[gz][gx][0],h=heightMin+(heightMax-heightMin)/(heightTileCount-1)*tileI;return h+playerHeight}renderer.xr.addEventListener("sessionstart",()=>{let xrRefSpace,rig;renderer.xr.getSession().requestReferenceSpace("local").then(rs=>{xrRefSpace=rs});const controller1=renderer.xr.getController(0),controller2=renderer.xr.getController(1);scene.add(controller1,controller2);rig=renderer.xr.getCamera(camera);let prevFrame=0;renderer.setAnimationLoop((ts)=>{renderer.render(scene,camera);let delta=(ts-prevFrame)/1000;prevFrame=ts;const session=renderer.xr.getSession();if(!session||!rig)return;let inputSources=session.inputSources;if(!inputSources)return;let moveX=0,moveZ=0;for(const src of inputSources){if(src&&src.gamepad){const gp=src.gamepad,axes=gp.axes;let isLeft=src.handedness==="left",isRight=src.handedness==="right";if(isRight){if(Math.abs(axes[2])>0.1||Math.abs(axes[3])>0.1){let r=rig.rotation.y,x=axes[2],z=axes[3];moveX+=Math.sin(r)*z+Math.cos(r)*x;moveZ+=Math.cos(r)*z-Math.sin(r)*x}}if(isLeft){if(Math.abs(axes[2])>0.5&&!snapPending){rig.rotation.y+=axes[2]>0?rotSnap:-rotSnap;snapPending=!0}else if(Math.abs(axes[2])<=0.3)snapPending=!1}}}if(moveX||moveZ){rig.position.x+=moveX*moveSpeed;rig.position.z+=moveZ*moveSpeed}rig.position.y=getGroundY(rig.position.x,rig.position.z)}})});if(renderer.xr.isPresenting)renderer.setAnimationLoop(()=>(0))});if(!renderer.xr.isPresenting)renderer.setAnimationLoop(()=>{camera.position.y=getGroundY(camera.position.x,camera.position.z);renderer.render(scene,camera)});window.addEventListener('resize',()=>{renderer.setSize(innerWidth,innerHeight);camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();});</script></body></html>
