
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);camera.position.set(0,4,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,10,0);scene.add(light);const gridSize=16,tileSize=1.5,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push({mesh:new THREE.Mesh(g,m),color:colors[i]});}const objTypes=[null,'cube','sphere','cone','cylinder'],objColors=[0,0xffaa00,0xaa00ff,0x00aaff,0x222222],objHeightAdjust=[0,.3,.3,.3,.3,0],possH=[],possO=[];function arr2D(len,fill){const a=[];for(let y=0;y<len;y++){a[y]=[];for(let x=0;x<len;x++)a[y][x]=fill.slice();}return a}function allowed(t,c){return[t,(t+1)%c,(t+c-1)%c]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapse(poss,count){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=count+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min===count+1){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let p=poss[ny][nx];if(p.length>1){const allowedSet=allowed(tile,count);if(p=p.filter(v=>allowedSet.includes(v)),0===p.length&&(p=[Math.random()*count|0]),p.length!==poss[ny][nx].length){poss[ny][nx]=p,queue.push([nx,ny])}}}}}}function getHeight(col){return 1.2*Math.sin(col/2)+2.3*Math.cos(col/3)+2;}possH.length=0;possO.length=0;let hopts=[],oopts=[];for(let i=0;i<tileCount;i++)hopts.push(i);for(let i=0;i<objTypes.length;i++)oopts.push(i);possH.push(...arr2D(gridSize,hopts));possO.push(...arr2D(gridSize,oopts));collapse(possH,tileCount);collapse(possO,objTypes.length-1);const meshes2D=[];for(let y=0;y<gridSize;y++){meshes2D[y]=[];for(let x=0;x<gridSize;x++){const idx=possH[y][x][0],mesh=tiles[idx].mesh.clone();const baseY=getHeight(idx);mesh.position.set((x-gridSize/2)*tileSize,baseY,(y-gridSize/2)*tileSize);mesh.material=mesh.material.clone();mesh.material.vertexColors=!0;let color=new THREE.Color(tiles[idx].color);mesh.material.color=color;scene.add(mesh);meshes2D[y][x]=mesh;const oidx=possO[y][x][0];if(oidx!==0){let geom=null;switch(objTypes[oidx]){case'cube':geom=new THREE.BoxGeometry(.7,.7,.7);break;case'sphere':geom=new THREE.SphereGeometry(.38,14,14);break;case'cone':geom=new THREE.ConeGeometry(.4,.8,14);break;case'cylinder':geom=new THREE.CylinderGeometry(.33,.33,.75,16);break;}if(geom){const om=new THREE.MeshStandardMaterial({color:objColors[oidx]});const ob=new THREE.Mesh(geom,om);ob.position.set(mesh.position.x,mesh.position.y+objHeightAdjust[oidx]+.5,mesh.position.z);scene.add(ob)}}}}let userHeight=1.3,velocity=new THREE.Vector3,moveX=0,moveZ=0,snapRotL=false,snapRotR=false,rotPending=0,snapAng=(Math.PI/6);let dummy=new THREE.Object3D;renderer.xr.addEventListener("sessionstart",()=>{const ses=renderer.xr.getSession();if(ses){ses.addEventListener("inputsourceschange",()=>{for(const src of ses.inputSources){if(src&&src.gamepad){}}});}});function updateMovement(){const ses=renderer.xr.getSession();if(!(ses&&ses.inputSources))return;let lx=0,ly=0,rx=0,ry=0;for(const src of ses.inputSources){if(src&&src.gamepad&&src.handedness){const g=src.gamepad;if(src.handedness==="left"){if(g.axes.length>2){lx=g.axes[2];ly=g.axes[3];}}else if(src.handedness==="right"){rx=g.axes[2];ry=g.axes[3];}}}let spd=0.05;moveX=ry;moveZ=rx;snapRotL=false;snapRotR=false;if(Math.abs(lx)>0.55){if(!rotPending){if(lx<0)snapRotL=!0;else snapRotR=!0;rotPending=16;}else{rotPending--}}else rotPending=0;}let camTarg=new THREE.Vector3,crowPos=new THREE.Vector3;renderer.setAnimationLoop(()=>{updateMovement();let c=renderer.xr.getCamera(camera);let dir=new THREE.Vector3,side=new THREE.Vector3;dir.set(0,0,-1).applyQuaternion(c.quaternion).setY(0).normalize();side.set(-1,0,0).applyQuaternion(c.quaternion).setY(0).normalize();if(moveX||moveZ){let moveVec=new THREE.Vector3;moveVec.copy(dir).multiplyScalar(moveX).add(side.multiplyScalar(moveZ));camera.position.add(moveVec.multiplyScalar(.15));}if(snapRotL){dummy.position.copy(camera.position);dummy.rotation.copy(camera.rotation);dummy.rotateY(snapAng);camera.rotation.y=dummy.rotation.y;}if(snapRotR){dummy.position.copy(camera.position);dummy.rotation.copy(camera.rotation);dummy.rotateY(-snapAng);camera.rotation.y=dummy.rotation.y;}let px=(camera.position.x/tileSize + gridSize/2)|0,py=(camera.position.z/tileSize + gridSize/2)|0;if(px<0)px=0;if(px>=gridSize)px=gridSize-1;if(py<0)py=0;if(py>=gridSize)py=gridSize-1;let baseY=meshes2D[py][px]?meshes2D[py][px].position.y:0;camera.position.y=baseY+userHeight;renderer.render(scene,camera)});</script></body></html>
```
