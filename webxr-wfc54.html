
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from"https://unpkg.com/three@0.157.0/build/three.module.js";import{VRButton}from"https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js";const scene=new THREE.Scene,renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight),renderer.xr.enabled=!0,document.body.appendChild(renderer.domElement),document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);camera.position.set(0,7,0),scene.add(camera);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0),scene.add(light);const gridSize=20,tileSize=1.5,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}const HCOLS=[0x449944,0x996600,0x225588,0x777777],objColors=[0xff0000,0x00ffff,0xffff00,0xffffff],HEIGHTS=4,OBJTYPES=4,groundPoss=[],objPoss=[];function allowedH(t){return[t,(t+1)%HEIGHTS,(t+HEIGHTS-1)%HEIGHTS]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}for(let y=0;y<gridSize;y++){groundPoss[y]=[],objPoss[y]=[];for(let x=0;x<gridSize;x++)groundPoss[y][x]=[0,1,2,3],objPoss[y][x]=[0,1,2,3]}function collapseWFC(poss,variants,allowedFn){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*15;){guard++;let min=variants+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const l=poss[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min===variants+1){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),val=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let p=poss[ny][nx];if(p.length>1){const allowedSet=allowedFn(val);if(p=p.filter(v=>allowedSet.includes(v)),p.length===0&&(p=[Math.random()*variants|0]),p.length!==poss[ny][nx].length){poss[ny][nx]=p,queue.push([nx,ny])}}}}}}collapseWFC(groundPoss,HEIGHTS,allowedH);collapseWFC(objPoss,OBJTYPES,()=>[0,1,2,3]);const objGeo=[null,new THREE.BoxGeometry(.6,.8,.6),new THREE.ConeGeometry(.35,.8,8),new THREE.SphereGeometry(.4,18,12)],fixedHeadHeight=1.6,gen=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const hIdx=groundPoss[y][x][0],h=hIdx*0.7,col=new THREE.Color(HCOLS[hIdx]),geom=new THREE.BoxGeometry(tileSize,h+.05,tileSize),vCol=[];for(let i=0;i<geom.attributes.position.count;i++)vCol.push(col.r,col.g,col.b);geom.setAttribute("color",new THREE.Float32BufferAttribute(vCol,3));const mat=new THREE.MeshStandardMaterial({vertexColors:!0,flatShading:!0});const mesh=new THREE.Mesh(geom,mat);mesh.position.set((x-gridSize/2)*tileSize,h*.5,(y-gridSize/2)*tileSize),scene.add(mesh),gen.push(mesh);const oIdx=objPoss[y][x][0];if(oIdx>0){const mat=new THREE.MeshStandardMaterial({color:objColors[oIdx]}),oMesh=new THREE.Mesh(objGeo[oIdx],mat);oMesh.position.set((x-gridSize/2)*tileSize,h+0.45,(y-gridSize/2)*tileSize),scene.add(oMesh)}}let user={x:gridSize/2,y:gridSize/2,rot:0};function getHeightAt(x,z){let gx=Math.round(x/tileSize+gridSize/2),gz=Math.round(z/tileSize+gridSize/2);if(gx>=0&&gx<gridSize&&gz>=0&&gz<gridSize)return groundPoss[gz][gx][0]*0.7;return 0}let pressedL=false,lastStickL=0,lastStickR=0;renderer.xr.addEventListener("sessionstart",()=>{const sess=renderer.xr.getSession();sess.addEventListener("inputsourceschange",()=>{});});renderer.setAnimationLoop(function(){const sess=renderer.xr.getSession();let stickL=0,stickR=0,stickY=0;if(sess){for(const src of sess.inputSources)if(src&&src.gamepad){const axes=src.gamepad.axes;if(src.handedness==="right")stickR=axes[2]||0,stickY=axes[3]||0;else stickL=axes[2]||0}}//Snap rotate head
if(stickL>0.7&&!pressedL){user.rot-=Math.PI/6,pressedL=!0}else if(stickL<-0.7&&!pressedL){user.rot+=Math.PI/6,pressedL=!0}else if(Math.abs(stickL)<.45)pressedL=!1;//Smooth move body
if(Math.abs(stickY)>.1){user.x+=Math.sin(user.rot-Math.PI/2)*(-stickY)*.15;user.y+=Math.cos(user.rot-Math.PI/2)*(-stickY)*.15;user.x=Math.max(1,Math.min(gridSize-2,user.x)),user.y=Math.max(1,Math.min(gridSize-2,user.y));}const px=(user.x-gridSize/2)*tileSize,pz=(user.y-gridSize/2)*tileSize,py=getHeightAt(px,pz)+fixedHeadHeight;camera.position.set(px,py,pz),camera.rotation.set(0,user.rot,0);renderer.render(scene,camera)});</script></body></html>
