
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);let playerHeight=1.6,playerPos=new THREE.Vector3(0,0,0),headRotY=0;camera.position.set(0,playerHeight,0);let light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);let gridSize=12,tileSize=1.5,tileCount=7,heightTileCount=6,heightRange=[0,5],baseColors=[16711680,65280,255,16776960,16711935,65535,16777215],heightColors=[0x4e9f3d,0x1e5128,0xf7c873,0xcd3131,0x329da8,0x435585];let objectTypes=["none","cube","sphere","pyramid"],objectColors=[0x000000,0x4287f5,0xff55cc,0x2ecc40],tiles=[],heightTiles=[];for(let i=0;i<tileCount;i++){let g=new THREE.BoxGeometry(tileSize,.17*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:baseColors[i]});tiles.push(new THREE.Mesh(g,m))}for(let i=0;i<heightTileCount;i++){let g=new THREE.BoxGeometry(tileSize,.6*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:heightColors[i]});heightTiles.push(new THREE.Mesh(g,m))}function allowedWrap(t,c){return[t,(t+1)%c,(t+c-1)%c]}function wfc2D(size,count,allowedF){let p=[];for(let y=0;y<size;y++){p[y]=[];for(let x=0;x<size;x++)p[y][x]=[...Array(count).keys()]}let unresolved=!0,guard=0;for(;unresolved&&guard<size*size*20;){guard++;let min=count+1,choices=[];for(let y=0;y<size;y++)for(let x=0;x<size;x++){let l=p[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min===count+1){unresolved=!1;break}let[cx,cy]=choices[Math.random()*choices.length|0],opts=p[cy][cx],pick=opts[Math.random()*opts.length|0];p[cy][cx]=[pick];let queue=[[cx,cy]];while(queue.length){let[qx,qy]=queue.shift(),tile=p[qy][qx][0];for(let[nx,ny]of[[qx+1,qy],[qx-1,qy],[qx,qy+1],[qx,qy-1]])if(nx>=0&&nx<size&&ny>=0&&ny<size){let poss=p[ny][nx];if(poss.length>1){let allowedSet=allowedF(tile);poss=poss.filter(v=>allowedSet.includes(v));if(!poss.length)poss=[Math.random()*count|0];if(poss.length!==p[ny][nx].length){p[ny][nx]=poss;queue.push([nx,ny])}}}}}return p.map(r=>r.map(a=>a[0]))}let heightMap=wfc2D(gridSize,heightTileCount,t=>allowedWrap(t,heightTileCount)),colorMap=wfc2D(gridSize,tileCount,t=>allowedWrap(t,tileCount)),objectMap=wfc2D(gridSize,objectTypes.length,t=>[...Array(objectTypes.length).keys()]);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let hIdx=heightMap[y][x],cIdx=colorMap[y][x],oIdx=objectMap[y][x],h=heightRange[0]+(hIdx/(heightTileCount-1))*(heightRange[1]-heightRange[0]),hx=(x-gridSize/2)*tileSize,hy=h/2,hz=(y-gridSize/2)*tileSize;let base=heightTiles[hIdx].clone();base.material=base.material.clone();base.material.color.setHex(baseColors[cIdx]);base.position.set(hx,hy,hz);scene.add(base);if(objectTypes[oIdx]!=="none"){let mesh;oIdx===1&&(mesh=new THREE.Mesh(new THREE.BoxGeometry(.7*tileSize,.7*tileSize,.7*tileSize),new THREE.MeshStandardMaterial({color:objectColors[oIdx]})));oIdx===2&&(mesh=new THREE.Mesh(new THREE.SphereGeometry(.35*tileSize,15,15),new THREE.MeshStandardMaterial({color:objectColors[oIdx]})));oIdx===3&&(mesh=new THREE.Mesh(new THREE.ConeGeometry(.5*tileSize,.7*tileSize,4),new THREE.MeshStandardMaterial({color:objectColors[oIdx]})),mesh.rotation.y=Math.random()*Math.PI);if(mesh)mesh.position.set(hx,h+playerHeight/4,hz),scene.add(mesh)}}let down=new THREE.Vector3(0,-1,0),playerMove=new THREE.Vector2(),snapRot=false,snapThreshold=0.5,snapAmount=Math.PI/6;renderer.xr.addEventListener("sessionstart",()=>{let refSpace=null,controllers=[];function handleMove(ctrl){if(!ctrl||!ctrl.inputSource||!ctrl.inputSource.gamepad)return;let gp=ctrl.inputSource.gamepad,axes=gp.axes;axes[2]&&Math.abs(axes[2])>snapThreshold&&!snapRot?(headRotY+=Math.sign(axes[2])*snapAmount,snapRot=!0):Math.abs(axes[2])<snapThreshold&&(snapRot=!1);let moveSpeed=0.06;playerMove.set(axes[3]*moveSpeed,axes[1]*moveSpeed)}for(let i=0;i<2;i++){let ctrl=renderer.xr.getController(i);scene.add(ctrl);controllers.push(ctrl)}renderer.setAnimationLoop(()=>{let direction=new THREE.Vector3(),forward=new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0),headRotY);let right=new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0),headRotY);direction.addScaledVector(forward,playerMove.y).addScaledVector(right,playerMove.x);playerPos.add(direction);let groundY=0;let gx=Math.round(playerPos.x/tileSize+gridSize/2),gz=Math.round(playerPos.z/tileSize+gridSize/2);if(gx>=0&&gz>=0&&gx<gridSize&&gz<gridSize){let hIdx=heightMap[gz][gx],h=heightRange[0]+(hIdx/(heightTileCount-1))*(heightRange[1]-heightRange[0]);groundY=h}else groundY=0;camera.position.set(playerPos.x,groundY+playerHeight,playerPos.z);camera.rotation.set(0,headRotY,0);renderer.render(scene,camera);for(let c of controllers)handleMove(c)})});</script></body></html>
