
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let gridSize=14,tileSize=1.5;const objTypes=["none","cube","sphere","cone"],objColor=[0xffffff,0xff4400,0x00ff66,0x3366ff],scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.05,100);const xrRoot=new THREE.Object3D;scene.add(xrRoot);let playerYOffset=1.6;const ambient=new THREE.HemisphereLight(0xffffff,0x999999);scene.add(ambient);const dirLight=new THREE.DirectionalLight(0xffffff,.5);dirLight.position.set(10,30,10),scene.add(dirLight);function genWaveFunctionCollapse(count,domain,compatFn){let poss=[];for(let y=0;y<count;y++){poss[y]=[];for(let x=0;x<count;x++)poss[y][x]=domain.slice();}let unresolved=!0,guard=0;while(unresolved&&guard<count*count*10){guard++;let min=99,choices=[];for(let y=0;y<count;y++)for(let x=0;x<count;x++){const l=poss[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min>domain.length){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];while(queue.length){const[qx,qy]=queue.shift(),t=poss[qy][qx][0];for(const[nxy]of[[qx+1,qy],[qx-1,qy],[qx,qy+1],[qx,qy-1]]){const[nx,ny]=nxy;if(nx<0||ny<0||nx>=count||ny>=count)continue;let p=poss[ny][nx];if(p.length>1){const allowed=compatFn(t);p=p.filter(v=>allowed.includes(v));if(!p.length)p=[domain[Math.random()*domain.length|0]];if(p.length!==poss[ny][nx].length){poss[ny][nx]=p;queue.push([nx,ny])}}}}}return poss}const heightDomain=[0,1,2,3,4,5],colormap=[0x35682d,0x88c070,0xf2cd86,0xe2b279,0xc48763,0xffffff],heightCompat=h=>[h,Math.max(0,h-1),Math.min(heightDomain.length-1,h+1)];const objectDomain=[0,1,2,3],objectCompat=o=>objectDomain;let heights=genWaveFunctionCollapse(gridSize,heightDomain,heightCompat),objects=genWaveFunctionCollapse(gridSize,objectDomain,objectCompat);const tileGeo=new THREE.PlaneGeometry(tileSize,tileSize),tiles=[];for(let i=0;i<heightDomain.length;i++){let m=new THREE.MeshStandardMaterial({color:colormap[i],vertexColors:!1,side:THREE.DoubleSide});tiles[i]=new THREE.Mesh(tileGeo,m)}tiles.forEach(t=>t.rotateX(-Math.PI/2));const objMaker=[()=>null,()=>new THREE.Mesh(new THREE.BoxGeometry(.6,.6,.6),new THREE.MeshStandardMaterial({color:objColor[1]})),()=>new THREE.Mesh(new THREE.SphereGeometry(.32,16,12),new THREE.MeshStandardMaterial({color:objColor[2]})),()=>{const m=new THREE.Mesh(new THREE.ConeGeometry(.32,.7,12),new THREE.MeshStandardMaterial({color:objColor[3]}));m.position.y=0.35;return m}];let gridMeshes=[],gridObjs=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const hidx=heights[y][x][0],mesh=tiles[hidx].clone();const hActual=hidx*0.65;mesh.position.set((x-gridSize/2)*tileSize,hActual,(y-gridSize/2)*tileSize);scene.add(mesh),gridMeshes.push(mesh);const oid=objects[y][x][0],obj=objMaker[oid]();if(obj)obj.position.set(mesh.position.x,mesh.position.y+(.4 if(oid==1) else .35),mesh.position.z),scene.add(obj),gridObjs.push(obj)}function getGroundHeightAt(x,z){let gx=Math.round(x/tileSize+gridSize/2),gz=Math.round(z/tileSize+gridSize/2);if(gx<0||gz<0||gx>=gridSize||gz>=gridSize)return 0;return heights[gz][gx][0]*0.65}let session;renderer.xr.addEventListener("sessionstart",()=>{session=renderer.xr.getSession()});function axesSmoothing(val,dead=0.15){return Math.abs(val)>dead?val:0}let moveState={x:0,z:0},snapTimer=0,snapDelay=280;renderer.setAnimationLoop(function(){if(renderer.xr.isPresenting&&session){const s=renderer.xr.getSession(),input=s.inputSources;for(const i of input)if(i&&i.gamepad){const g=i.gamepad,ax=g.axes,btn=g.buttons;let handed=i.handedness;if(handed=="right"){moveState.x=axesSmoothing(ax[2]);moveState.z=axesSmoothing(ax[3])}else if(handed=="left"&&Math.abs(ax[2])>0.6&&Date.now()>snapTimer){const a=ax[2];xrRoot.rotation.y+=a>0?-(Math.PI/8):(Math.PI/8);snapTimer=Date.now()+snapDelay}}let head=renderer.xr.getCamera(camera);let forward=new THREE.Vector3(0,0,-1).applyQuaternion(xrRoot.quaternion),right=new THREE.Vector3(1,0,0).applyQuaternion(xrRoot.quaternion);let dx=moveState.x*0.07,dz=moveState.z*0.07;if(Math.abs(dx)+Math.abs(dz))xrRoot.position.add(forward.multiplyScalar(dz)).add(right.multiplyScalar(dx));let px=xrRoot.position.x,pz=xrRoot.position.z,gheight=getGroundHeightAt(px,pz);xrRoot.position.y=gheight+playerYOffset;if(!xrRoot.parent)scene.add(xrRoot);xrRoot.add(head)}});window.addEventListener("resize",()=>{camera.aspect=window.innerWidth/window.innerHeight,camera.updateProjectionMatrix(),renderer.setSize(window.innerWidth,window.innerHeight)});</script></body></html>
