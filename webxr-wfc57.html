
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const tempCamRig=new THREE.Group();scene.add(tempCamRig);tempCamRig.add(camera);const gridSize=20,tileSize=1.5,heightMin=0,heightMax=6,heightTileCount=5,heightColors=[0x224488,0x44aa77,0x88cc44,0xffee99,0xffffff],objectTypes=[null,"cube","sphere","cylinder","cone"],objectColors=[0x000000,0xff0000,0x00ff00,0x0000ff,0xffff00],heightPoss=[],objectPoss=[];function genLayer(poss,states){for(let y=0;y<gridSize;y++){poss[y]=[];for(let x=0;x<gridSize;x++)poss[y][x]=Array.from({length:states},(_,i)=>i)}}function allowedHeight(h){return[h,Math.max(0,h-1),Math.min(heightTileCount-1,h+1)]}function allowedObj(o){return[0,1,2,3,4]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapseLayer(poss,allowedFn,states){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*20;){guard++;let min=states+1,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=poss[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(states+1===min){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=poss[cy][cx],pick=options[Math.random()*options.length|0];poss[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=poss[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let p=poss[ny][nx];if(p.length>1){const allow=allowedFn(tile);if(p=p.filter(v=>allow.includes(v)),0===p.length&&(p=[Math.random()*states|0]),p.length!==poss[ny][nx].length){poss[ny][nx]=p,queue.push([nx,ny])}}}}}}genLayer(heightPoss,heightTileCount);collapseLayer(heightPoss,allowedHeight,heightTileCount);genLayer(objectPoss,objectTypes.length);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){objectPoss[y][x]=objectPoss[y][x].filter(v=>v===0||Math.random()<.15||heightPoss[y][x][0]>=2);if(!objectPoss[y][x].length)objectPoss[y][x]=[0]}collapseLayer(objectPoss,allowedObj,objectTypes.length);const tileGeo=new THREE.BoxGeometry(tileSize,.2*tileSize,tileSize);for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const h=heightPoss[y][x][0],clr=heightColors[h],mat=new THREE.MeshStandardMaterial({color:clr}),ypos=h/tileSize*.8+heightMin,mesh=new THREE.Mesh(tileGeo,mat);mesh.position.set((x-gridSize/2)*tileSize,ypos,(y-gridSize/2)*tileSize);scene.add(mesh);if(objectPoss[y][x][0]!==0){let o=objectPoss[y][x][0],obj,k=tileSize/2;switch(o){case 1:obj=new THREE.Mesh(new THREE.BoxGeometry(k,k,k),new THREE.MeshStandardMaterial({color:objectColors[o]}));break;case 2:obj=new THREE.Mesh(new THREE.SphereGeometry(k*.5,16,16),new THREE.MeshStandardMaterial({color:objectColors[o]}));break;case 3:obj=new THREE.Mesh(new THREE.CylinderGeometry(k*.4,k*.4,k,.8),new THREE.MeshStandardMaterial({color:objectColors[o]}));break;case 4:obj=new THREE.Mesh(new THREE.ConeGeometry(k*.4,k,.8),new THREE.MeshStandardMaterial({color:objectColors[o]}));break;}if(obj)obj.position.set((x-gridSize/2)*tileSize,ypos+.7*k,(y-gridSize/2)*tileSize),scene.add(obj)}}let moveDir=new THREE.Vector3(),yaw=0,snapRotInProgress=!1,stick0=0,stick1=0;renderer.xr.addEventListener("sessionstart",()=>{const session=renderer.xr.getSession();session.addEventListener("inputsourceschange",updateInputSources)});let gamepads=[];function updateInputSources(){gamepads=Array.from(renderer.xr.getSession().inputSources).map(s=>s.gamepad).filter(Boolean)}function pollGamepads(){const ses=renderer.xr.getSession();if(ses&&gamepads.length){for(let i=0;i<gamepads.length;i++){let gp=gamepads[i];if(gp&&gp.axes.length>=4){let lx=gp.axes[2]||0,ly=gp.axes[3]||0,rx=gp.axes[0]||0,ry=gp.axes[1]||0;if(Math.abs(rx)>.6&&!snapRotInProgress){yaw+=Math.PI/8*Math.sign(rx);snapRotInProgress=!0}else if(Math.abs(rx)<.2)snapRotInProgress=!1;moveDir.set(lx,0,ly).clampLength(0,1)}}}}function updateCamRig(){let speed=0.07;pollGamepads();let d=moveDir.length();if(d>0){let angle=yaw;let dx=moveDir.x*Math.cos(angle)-moveDir.z*Math.sin(angle),dz=moveDir.x*Math.sin(angle)+moveDir.z*Math.cos(angle);tempCamRig.position.x+=dx*speed;tempCamRig.position.z+=dz*speed}tempCamRig.rotation.y=yaw;let px=tempCamRig.position.x/(tileSize)-.5+gridSize/2|0,py=tempCamRig.position.z/(tileSize)-.5+gridSize/2|0;px=Math.max(0,Math.min(gridSize-1,px));py=Math.max(0,Math.min(gridSize-1,py));let groundH=heightPoss[py][px][0]/tileSize*.8+heightMin;camera.position.y=groundH+1.0}window.addEventListener("resize",()=>{renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix()});renderer.setAnimationLoop(()=>{updateCamRig();renderer.render(scene,camera)});</script></body></html>
