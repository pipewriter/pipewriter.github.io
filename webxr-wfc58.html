
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import * as THREE from "https://unpkg.com/three@0.157.0/build/three.module.js";import {VRButton} from "https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js";let scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:true});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=true;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const PLAYER_HEIGHT=1.7;let player=new THREE.Object3D();scene.add(player);player.add(camera);let globalY=0;const light=new THREE.DirectionalLight(0xffffff,1);light.position.set(0,1,0);scene.add(light);const gridSize=20,tileSize=1.5,tileCount=7,heightCount=5,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,0.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}const basePoss=[],objPoss=[];for(let y=0;y<gridSize;y++){basePoss[y]=[];objPoss[y]=[];for(let x=0;x<gridSize;x++){basePoss[y][x]=[...Array(heightCount).keys()];objPoss[y][x]=[0,1,2,3,4,5,6,7]}}function allowedArr(c,arrLen){return[c,(c+1)%arrLen,(c+arrLen-1)%arrLen]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapseWFC(possArr,states){let unresolved=true,guard=0;while(unresolved&&guard<gridSize*gridSize*20){guard++;let min=999,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=possArr[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(min>gridSize*gridSize){unresolved=false;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=possArr[cy][cx],pick=options[Math.random()*options.length|0];possArr[cy][cx]=[pick];const queue=[[cx,cy]];while(queue.length){const[qx,qy]=queue.shift(),tile=possArr[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=possArr[ny][nx];if(poss.length>1){const allow=allowedArr(tile,states);const newPoss=poss.filter(v=>allow.includes(v));if(newPoss.length===0){possArr[ny][nx]=[Math.floor(Math.random()*states)]}else if(newPoss.length!==poss.length){possArr[ny][nx]=newPoss;queue.push([nx,ny])}}}}}}collapseWFC(basePoss,heightCount);collapseWFC(objPoss,tileCount+1);let terrain=new Array(gridSize);for(let y=0;y<gridSize;y++){terrain[y]=new Array(gridSize);for(let x=0;x<gridSize;x++){const h=basePoss[y][x][0],tileIndex=objPoss[y][x][0],heightVal=(h/(heightCount-1))*3,mesh=tiles[Math.min(tileIndex,tiles.length-1)].clone();mesh.position.set((x-gridSize/2)*tileSize,heightVal/2,(y-gridSize/2)*tileSize);mesh.scale.y=heightVal/1.2+0.05;const color=new THREE.Color().setHSL(h/heightCount,0.5,0.5);mesh.material=mesh.material.clone();mesh.material.color.copy(color);scene.add(mesh);terrain[y][x]={height:heightVal}}}const objects=[];const objColors=[0xffffff,0x808080,0xff00ff,0x00ffff,0xff8800,0x118822,0x8888ff];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const obj=objPoss[y][x][0];if(obj===0)continue;let g,m,mesh;switch(obj%4){case 1:g=new THREE.SphereGeometry(tileSize*0.25,12,8);break;case 2:g=new THREE.BoxGeometry(tileSize*0.4,tileSize*0.4,tileSize*0.4);break;case 3:g=new THREE.ConeGeometry(tileSize*0.25,tileSize*0.45,10);break;}if(g){m=new THREE.MeshStandardMaterial({color:objColors[obj%objColors.length]});mesh=new THREE.Mesh(g,m);mesh.position.set((x-gridSize/2)*tileSize,terrain[y][x].height+tileSize*0.18,(y-gridSize/2)*tileSize);scene.add(mesh);objects.push(mesh)}}let moveVec=new THREE.Vector3(),speed=0.06,rotating=false,rotTarget=0,snapRot=Math.PI/7;let prevFrame=performance.now();let yaw=new THREE.Object3D();scene.add(yaw);yaw.position.set(0,0,0);yaw.add(player);renderer.xr.addEventListener("sessionstart",()=>{let local=yaw.rotation.y;rotTarget=local});function getFloorHeight(x,z){x=(x+gridSize/2)/tileSize;z=(z+gridSize/2)/tileSize;let xi=Math.floor(x),zi=Math.floor(z),xi1=Math.min(xi+1,gridSize-1),zi1=Math.min(zi+1,gridSize-1);let h00=terrain[zi >= gridSize ? gridSize-1 : zi][xi >= gridSize ? gridSize-1 : xi].height;let h10=terrain[zi][xi1].height;let h01=terrain[zi1][xi].height;let h11=terrain[zi1][xi1].height;let fx=x-xi,fz=z-zi,ha=h00*(1-fx)+h10*fx,hb=h01*(1-fx)+h11*fx;return ha*(1-fz)+hb*fz}function animateVRControllerMove(){const session=renderer.xr.getSession();if(!session)return;let input=Array.from(session.inputSources);let xAxis=0,zAxis=0,leftX=0,snapPressed=false;input.forEach(src=>{if(!src.gamepad)return;let g=src.gamepad;if(src.handedness==="right"){xAxis=g.axes[2]||0;zAxis=-(g.axes[3]||0);}else if(src.handedness==="left"){leftX=g.axes[2]||0;if(leftX>0.6&&!rotating){rotTarget+=snapRot;rotating=true;snapPressed=true;}else if(leftX<-0.6&&!rotating){rotTarget-=snapRot;rotating=true;snapPressed=true;}else if(Math.abs(leftX)<0.2){rotating=false;}}});if(!snapPressed)rotating=false;let dt=Math.min((performance.now()-prevFrame)/16.67,3);prevFrame=performance.now();let angle=yaw.rotation.y;moveVec.set(xAxis,0,zAxis);if(moveVec.length()>0.01){moveVec.normalize().multiplyScalar(speed*dt);moveVec.applyAxisAngle(new THREE.Vector3(0,1,0),angle);yaw.position.add(moveVec)}yaw.rotation.y+=(rotTarget-yaw.rotation.y)*0.24;let posX=yaw.position.x,posZ=yaw.position.z;let gndY=getFloorHeight(posX/tileSize,posZ/tileSize);player.position.y=gndY+PLAYER_HEIGHT-camera.position.y;}renderer.setAnimationLoop(()=>{animateVRControllerMove();renderer.render(scene,camera)});</script></body></html>
