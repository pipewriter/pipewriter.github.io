
<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';import {VRButton} from 'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';let scene=new THREE.Scene,renderer=new THREE.WebGLRenderer({antialias:1});renderer.setSize(window.innerWidth,window.innerHeight),renderer.xr.enabled=!0,document.body.appendChild(renderer.domElement),document.body.appendChild(VRButton.createButton(renderer));let camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);const PLAYER_HEIGHT=1.7;let player={x:0,y:0,camY:0,rot:0};camera.position.set(0,PLAYER_HEIGHT,3);let light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0),scene.add(light);const gridSize=18,tileSize=1.5,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[],elevPoints=[.7,1,1.3,2,2.7,.7,1.5],elevColors=[0x6ecaf7,0x9ed18b,0xdfc666,0xd0a57a,0xcbe6ef,0x7d8986,0x888];for(let i=0;i<tileCount;i++){let g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}let elevPoss=[],objPoss=[];for(let y=0;y<gridSize;y++){elevPoss[y]=[];objPoss[y]=[];for(let x=0;x<gridSize;x++)elevPoss[y][x]=[0,1,2,3,4,5,6],objPoss[y][x]=[0,1,2,3]}function allowed(t){return[t,(t+1)%tileCount,(t-1+tileCount)%tileCount]}function allowedObj(t){return[0,1,2,3]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(([a,b])=>a>=0&&a<gridSize&&b>=0&&b<gridSize)}function collapse(poss,allowSet,limit){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*12;){guard++;let min=99,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){let l=poss[y][x].length;l>1&&l<min?(min=l,choices=[[x,y]]):l===min&&choices.push([x,y])}if(min===99)break;let[cx,cy]=choices[Math.random()*choices.length|0],pick=poss[cy][cx][Math.random()*poss[cy][cx].length|0];poss[cy][cx]=[pick];let q=[[cx,cy]];for(;q.length;){let[qx,qy]=q.shift(),t=poss[qy][qx][0];for(let[nx,ny]of neighbors(qx,qy)){let p=poss[ny][nx];if(p.length>1){let a=allowSet(t);if((p=p.filter(v=>a.includes(v))).length===0&&(p=[Math.random()*limit|0]),p.length!==poss[ny][nx].length)poss[ny][nx]=p,q.push([nx,ny])}}}}}collapse(elevPoss,allowed,tileCount);collapse(objPoss,allowedObj,4);function genTile(x,y){let elevIdx=elevPoss[y][x][0],objIdx=objPoss[y][x][0];let elev=elevPoints[elevIdx],color=elevColors[elevIdx]||0xffffff;let g=new THREE.BoxGeometry(tileSize,elev,tileSize),m=new THREE.MeshStandardMaterial({color}),mesh=new THREE.Mesh(g,m);mesh.position.set((x-gridSize/2)*tileSize,elev/2,(y-gridSize/2)*tileSize),scene.add(mesh);if(objIdx>0){let objCol=[0xffffff,0xcc2222,0x31e835,0x314be2][objIdx],o;switch(objIdx){case 1:o=new THREE.SphereGeometry(tileSize*.33);break;case 2:o=new THREE.CylinderGeometry(tileSize*0.18,tileSize*0.18,tileSize*0.6,12);break;case 3:o=new THREE.BoxGeometry(tileSize*0.5,tileSize*0.7,tileSize*0.5);break}let om=new THREE.MeshStandardMaterial({color:objCol}),mesh2=new THREE.Mesh(o,om);mesh2.position.set(0,elev/2+tileSize*.33,0),mesh.add(mesh2)}}for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++)genTile(x,y);let xrGamepads=[];function updateXRControls(){let s=renderer.xr.getSession();if(!s)return;let input=s.inputSources;xrGamepads.length=input.length;for(let i=0;i<input.length;i++){let src=input[i];if(src&&src.gamepad)xrGamepads[i]=src.gamepad}}let prevLeftX=0,prevRightX=0,snapThreshold=0.7,rotating=!1;function movePlayer(dt){let moveZ=0,moveX=0,rot=0;for(let g of xrGamepads){if(!g||!g.axes)return;let[x1,y1,x2,y2]=g.axes;let isLeft=g.hand=="left"||g.hand==null&&g.index==0;if(isLeft){if(Math.abs(x1)>snapThreshold&&!rotating){player.rot+=Math.sign(x1)*Math.PI/4,rotating=!0}else if(Math.abs(x1)<.3)rotating=!1}else{let ang=player.rot;moveZ-=y2*dt*2.5,moveX+=x2*dt*2.5}}let dx=-Math.sin(player.rot)*moveZ+Math.cos(player.rot)*moveX,dz=-Math.cos(player.rot)*moveZ-Math.sin(player.rot)*moveX,nx=THREE.MathUtils.clamp(player.x+dx,-gridSize*tileSize/2+tileSize/2,gridSize*tileSize/2-tileSize/2),nz=THREE.MathUtils.clamp(player.y+dz,-gridSize*tileSize/2+tileSize/2,gridSize*tileSize/2-tileSize/2),cx=gridSize/2+Math.round(nx/tileSize),cy=gridSize/2+Math.round(nz/tileSize),h=PLAYER_HEIGHT;if(cx>=0&&cy>=0&&cx<gridSize&&cy<gridSize)h=elevPoints[elevPoss[cy][cx][0]]+PLAYER_HEIGHT-0.25;player.x=nx,player.y=nz;player.camY=h}renderer.setAnimationLoop(function(ts){updateXRControls();movePlayer(0.025);camera.position.set(player.x,player.camY,player.y);camera.rotation.y=player.rot;renderer.render(scene,camera)});window.addEventListener("resize",()=>{let w=window.innerWidth,h=window.innerHeight;camera.aspect=w/h,camera.updateProjectionMatrix(),renderer.setSize(w,h)});</script></body></html>
```
