<!DOCTYPE html><html><head><meta charset="utf-8"><title>WFC XR</title><style>body{margin:0;overflow:hidden}</style></head><body><script type="module">import*as THREE from'https://unpkg.com/three@0.157.0/build/three.module.js';import{VRButton}from'https://unpkg.com/three@0.157.0/examples/jsm/webxr/VRButton.js';const scene=new THREE.Scene(),renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(window.innerWidth,window.innerHeight);renderer.xr.enabled=!0;document.body.appendChild(renderer.domElement);document.body.appendChild(VRButton.createButton(renderer));const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,.1,1e3);camera.position.set(0,20,0);camera.lookAt(0,0,0);const light=new THREE.DirectionalLight(16777215,1);light.position.set(0,1,0);scene.add(light);const gridSize=10,tileSize=1.5,tileCount=7,colors=[16711680,65280,255,16776960,16711935,65535,16777215],tiles=[];for(let i=0;i<tileCount;i++){const g=new THREE.BoxGeometry(tileSize,.15*tileSize,tileSize),m=new THREE.MeshStandardMaterial({color:colors[i]});tiles.push(new THREE.Mesh(g,m))}const possibilities=[];for(let y=0;y<gridSize;y++){possibilities[y]=[];for(let x=0;x<gridSize;x++)possibilities[y][x]=[0,1,2,3,4,5,6]}function allowed(t){return[t,(t+1)%tileCount,(t+tileCount-1)%tileCount]}function neighbors(x,y){return[[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(p=>p[0]>=0&&p[0]<gridSize&&p[1]>=0&&p[1]<gridSize)}function collapse(){let unresolved=!0,guard=0;for(;unresolved&&guard<gridSize*gridSize*10;){guard++;let min=8,choices=[];for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const len=possibilities[y][x].length;len>1&&len<min?(min=len,choices=[[x,y]]):len===min&&choices.push([x,y])}if(8===min){unresolved=!1;break}const[cx,cy]=choices[Math.random()*choices.length|0],options=possibilities[cy][cx],pick=options[Math.random()*options.length|0];possibilities[cy][cx]=[pick];const queue=[[cx,cy]];for(;queue.length;){const[qx,qy]=queue.shift(),tile=possibilities[qy][qx][0];for(const[nx,ny]of neighbors(qx,qy)){let poss=possibilities[ny][nx];if(poss.length>1){const allowedSet=allowed(tile);if(poss=poss.filter(v=>allowedSet.includes(v)),0===poss.length&&(poss=[Math.random()*tileCount|0]),poss.length!==possibilities[ny][nx].length){possibilities[ny][nx]=poss,queue.push([nx,ny])}}}}}}collapse();for(let y=0;y<gridSize;y++)for(let x=0;x<gridSize;x++){const tileIndex=possibilities[y][x][0],mesh=tiles[tileIndex].clone();mesh.position.set((x-gridSize/2)*tileSize,0,(y-gridSize/2)*tileSize);scene.add(mesh)}renderer.setAnimationLoop(()=>{renderer.render(scene,camera)});</script></body></html>